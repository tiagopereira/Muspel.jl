<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home Â· Muspel.jl</title><script data-outdated-warner src="assets/warner.js"></script><link rel="canonical" href="https://tiagopereira.github.io/Muspel.jl/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.044/juliamono.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>Muspel.jl</a></span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/tiagopereira/Muspel.jl/blob/main/docs/src/index.md#" title="Edit on GitHub"><span class="docs-icon fab">ï‚›</span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Muspel"><a class="docs-heading-anchor" href="#Muspel">Muspel</a><a id="Muspel-1"></a><a class="docs-heading-anchor-permalink" href="#Muspel" title="Permalink"></a></h1><p>Documentation for <a href="https://github.com/tiagopereira/Muspel.jl">Muspel</a>.</p><ul><li><a href="#Muspel.Atmosphere1D"><code>Muspel.Atmosphere1D</code></a></li><li><a href="#Muspel.ExtinctionItpLTE"><code>Muspel.ExtinctionItpLTE</code></a></li><li><a href="#Muspel.ExtinctionItpNLTE"><code>Muspel.ExtinctionItpNLTE</code></a></li><li><a href="#Muspel._assign_unit-Tuple{Dict}"><code>Muspel._assign_unit</code></a></li><li><a href="#Muspel._read_broadening_single-Tuple{Dict, Vararg{Any, 5}}"><code>Muspel._read_broadening_single</code></a></li><li><a href="#Muspel._read_transition-Tuple{Dict, Any, Any}"><code>Muspel._read_transition</code></a></li><li><a href="#Muspel._spline_coeffs-Tuple{Any, Any}"><code>Muspel._spline_coeffs</code></a></li><li><a href="#Muspel._spline_stencil-Tuple{Any, Any, Any}"><code>Muspel._spline_stencil</code></a></li><li><a href="#Muspel._w2-Tuple{T} where T&lt;:AbstractFloat"><code>Muspel._w2</code></a></li><li><a href="#Muspel.blackbody_Î»-Union{Tuple{T2}, Tuple{T1}, Tuple{T1, T2}} where {T1&lt;:Real, T2&lt;:AbstractFloat}"><code>Muspel.blackbody_Î»</code></a></li><li><a href="#Muspel.calc_line_1D!-Union{Tuple{T}, Tuple{AtomicLine, RTBuffer{T}, Atmosphere1D{1, T, A, V} where {A&lt;:AbstractVector{T}, V&lt;:AbstractVector{T}}, AbstractVector{T}, AbstractVector{T}, ExtinctionItpNLTE{var&quot;#s38&quot;, T2, ITP_2D, ITP_1D} where {var&quot;#s38&quot;&lt;:Real, T2, ITP_2D&lt;:(Interpolations.AbstractInterpolation{var&quot;#s38&quot;, 2}), ITP_1D&lt;:(Interpolations.AbstractInterpolation{var&quot;#s38&quot;, 1})}, Interpolations.AbstractInterpolation{&lt;:Real, 2}}} where T&lt;:AbstractFloat"><code>Muspel.calc_line_1D!</code></a></li><li><a href="#Muspel.calc_Î»line_MULTI-Union{Tuple{T}, Tuple{Union{Unitful.Quantity{T, ð‹, U}, Unitful.Level{L, S, Unitful.Quantity{T, ð‹, U}} where {L, S}} where U, Any, T, T, Union{Unitful.Quantity{T, ð‹ ð“^-1, U}, Unitful.Level{L, S, Unitful.Quantity{T, ð‹ ð“^-1, U}} where {L, S}} where U}} where T&lt;:Real"><code>Muspel.calc_Î»line_MULTI</code></a></li><li><a href="#Muspel.calc_Î»line_RH-Union{Tuple{T}, Tuple{Union{Unitful.Quantity{T, ð‹, U}, Unitful.Level{L, S, Unitful.Quantity{T, ð‹, U}} where {L, S}} where U, Any, T, T, Union{Unitful.Quantity{T, ð‹ ð“^-1, U}, Unitful.Level{L, S, Unitful.Quantity{T, ð‹ ð“^-1, U}} where {L, S}} where U}} where T&lt;:Real"><code>Muspel.calc_Î»line_RH</code></a></li><li><a href="#Muspel.create_Ïƒ_itp_LTE-Union{Tuple{T}, Tuple{Real, AbstractRange{T}, AbstractRange{T}, AtomicModel, AbstractVector{AtomicModel}, Vector{Vector{Interpolations.FilledExtrapolation}}}} where T&lt;:Real"><code>Muspel.create_Ïƒ_itp_LTE</code></a></li><li><a href="#Muspel.create_Ïƒ_itp_NLTE-Union{Tuple{T}, Tuple{Real, AbstractRange{T}, AbstractRange{T}, AbstractVector{AtomicModel}, Vector{Vector{Interpolations.FilledExtrapolation}}}} where T&lt;:Real"><code>Muspel.create_Ïƒ_itp_NLTE</code></a></li><li><a href="#Muspel.damping-Union{Tuple{T}, Tuple{T, Real, Real}} where T&lt;:Real"><code>Muspel.damping</code></a></li><li><a href="#Muspel.doppler_width-Union{Tuple{T}, Tuple{Any, Any, T}} where T&lt;:AbstractFloat"><code>Muspel.doppler_width</code></a></li><li><a href="#Muspel.feautrier-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, AbstractVector{T}}} where T&lt;:AbstractFloat"><code>Muspel.feautrier</code></a></li><li><a href="#Muspel.get_atoms_bf_interpolant-Tuple{AbstractVector{AtomicModel}}"><code>Muspel.get_atoms_bf_interpolant</code></a></li><li><a href="#Muspel.get_Ïƒ_itp-Tuple{Muspel.AbstractAtmos, Real, Vector{String}}"><code>Muspel.get_Ïƒ_itp</code></a></li><li><a href="#Muspel.h_ionfrac_saha-Union{Tuple{T}, Tuple{T, Real}} where T&lt;:Real"><code>Muspel.h_ionfrac_saha</code></a></li><li><a href="#Muspel.incline_atmos-Tuple{Muspel.AbstractAtmos3D, Real, Real}"><code>Muspel.incline_atmos</code></a></li><li><a href="#Muspel.incline_data!-Tuple{AbstractArray{&lt;:Real, 3}, AbstractVector, Vararg{Real, 4}}"><code>Muspel.incline_data!</code></a></li><li><a href="#Muspel.incline_data_inv!-Tuple{AbstractArray{&lt;:Real, 3}, AbstractVector, Vararg{Real, 4}}"><code>Muspel.incline_data_inv!</code></a></li><li><a href="#Muspel.piecewise_1D_linear-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, AbstractVector{T}}} where T&lt;:AbstractFloat"><code>Muspel.piecewise_1D_linear</code></a></li><li><a href="#Muspel.piecewise_1D_linear!-Union{Tuple{T}, NTuple{4, AbstractVector{T}}} where T&lt;:AbstractFloat"><code>Muspel.piecewise_1D_linear!</code></a></li><li><a href="#Muspel.piecewise_1D_nn-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, AbstractVector{T}}} where T&lt;:AbstractFloat"><code>Muspel.piecewise_1D_nn</code></a></li><li><a href="#Muspel.project_vector!-Union{Tuple{A}, Tuple{A, A, A, Real, Real}} where A&lt;:(AbstractArray{&lt;:Real})"><code>Muspel.project_vector!</code></a></li><li><a href="#Muspel.read_atmos_hpops_multi3d-Tuple{Any, Any, Any}"><code>Muspel.read_atmos_hpops_multi3d</code></a></li><li><a href="#Muspel.read_atmos_hpops_rh-Tuple{Any, Any}"><code>Muspel.read_atmos_hpops_rh</code></a></li><li><a href="#Muspel.read_atmos_multi3d-Tuple{Any, Any}"><code>Muspel.read_atmos_multi3d</code></a></li><li><a href="#Muspel.read_atmos_rh-Tuple{Any}"><code>Muspel.read_atmos_rh</code></a></li><li><a href="#Muspel.read_atom-Tuple{Any}"><code>Muspel.read_atom</code></a></li><li><a href="#Muspel.read_continuum-Tuple{Dict, Any, Any, Any}"><code>Muspel.read_continuum</code></a></li><li><a href="#Muspel.read_line-Tuple{Dict, Vararg{Any, 6}}"><code>Muspel.read_line</code></a></li><li><a href="#Muspel.read_mesh-Tuple{Any}"><code>Muspel.read_mesh</code></a></li><li><a href="#Muspel.read_pops_multi3d-NTuple{5, Any}"><code>Muspel.read_pops_multi3d</code></a></li><li><a href="#Muspel.read_pops_rh-Tuple{Any, Any}"><code>Muspel.read_pops_rh</code></a></li><li><a href="#Muspel.saha_boltzmann-Union{Tuple{T}, Tuple{N}, Tuple{StaticArraysCore.SVector{N, &lt;:Real}, StaticArraysCore.SVector{N, &lt;:Real}, StaticArraysCore.SVector{N, &lt;:Real}, T, T, Real}} where {N, T&lt;:AbstractFloat}"><code>Muspel.saha_boltzmann</code></a></li><li><a href="#Muspel.saha_boltzmann!-Union{Tuple{T}, Tuple{N}, Tuple{StaticArraysCore.SVector{N, &lt;:Real}, StaticArraysCore.SVector{N, &lt;:Real}, StaticArraysCore.SVector{N, &lt;:Real}, Real, Real, Real, AbstractVector{T}}} where {N, T&lt;:AbstractFloat}"><code>Muspel.saha_boltzmann!</code></a></li><li><a href="#Muspel.Î±_cont-Union{Tuple{T}, Tuple{ExtinctionItpNLTE{var&quot;#s42&quot;, T2, ITP_2D, ITP_1D} where {var&quot;#s42&quot;&lt;:Real, T2, ITP_2D&lt;:(Interpolations.AbstractInterpolation{var&quot;#s42&quot;, 2}), ITP_1D&lt;:(Interpolations.AbstractInterpolation{var&quot;#s42&quot;, 1})}, Vararg{T, 4}}} where T&lt;:AbstractFloat"><code>Muspel.Î±_cont</code></a></li><li><a href="#Muspel.Î±_cont-Union{Tuple{T}, Tuple{ExtinctionItpLTE{var&quot;#s42&quot;, T2, ITP_2D} where {var&quot;#s42&quot;&lt;:Real, T2, ITP_2D&lt;:(Interpolations.AbstractInterpolation{var&quot;#s42&quot;, 2})}, T, T, T}} where T&lt;:AbstractFloat"><code>Muspel.Î±_cont</code></a></li><li><a href="#Muspel.Î±_cont_no_itp-Union{Tuple{T}, NTuple{5, T}} where T&lt;:AbstractFloat"><code>Muspel.Î±_cont_no_itp</code></a></li><li><a href="#Muspel.ÏƒH_atoms_bf-Union{Tuple{T}, Tuple{Vector{Vector{Interpolations.FilledExtrapolation}}, AbstractVector{AtomicModel}, Real, T, T}} where T&lt;:AbstractFloat"><code>Muspel.ÏƒH_atoms_bf</code></a></li><li><a href="#Muspel.ÏƒH_continuum-Union{Tuple{T}, Tuple{Real, T, T, Real}} where T&lt;:AbstractFloat"><code>Muspel.ÏƒH_continuum</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="Muspel.Atmosphere1D" href="#Muspel.Atmosphere1D"><code>Muspel.Atmosphere1D</code></a> â€” <span class="docstring-category">Type</span></header><section><div><p>Type for 1D atmospheres. Can contain both 1D only, or 1.5D atmospheres (multiple columns of 1D atmospheres).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tiagopereira/Muspel.jl/blob/407440565a4b0a3d62bbb9a899c2b292dbb41b7c/src/types.jl#L12-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Muspel.ExtinctionItpLTE" href="#Muspel.ExtinctionItpLTE"><code>Muspel.ExtinctionItpLTE</code></a> â€” <span class="docstring-category">Type</span></header><section><div><p>Interpolant structure for continuum extinction, for use when hydrogen populations are computed in LTE (simplifies calculations).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tiagopereira/Muspel.jl/blob/407440565a4b0a3d62bbb9a899c2b292dbb41b7c/src/background.jl#L18-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Muspel.ExtinctionItpNLTE" href="#Muspel.ExtinctionItpNLTE"><code>Muspel.ExtinctionItpNLTE</code></a> â€” <span class="docstring-category">Type</span></header><section><div><p>Interpolant structure for continuum extinction, for use when hydrogen populations are given explicitly (e.g. non-equilibrium ionisation or NLTE).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tiagopereira/Muspel.jl/blob/407440565a4b0a3d62bbb9a899c2b292dbb41b7c/src/background.jl#L33-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Muspel._assign_unit-Tuple{Dict}" href="#Muspel._assign_unit-Tuple{Dict}"><code>Muspel._assign_unit</code></a> â€” <span class="docstring-category">Method</span></header><section><div><p>Return a value with a unit given a dictionary read from a YAML file.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tiagopereira/Muspel.jl/blob/407440565a4b0a3d62bbb9a899c2b292dbb41b7c/src/read_utils.jl#L234-L236">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Muspel._read_broadening_single-Tuple{Dict, Vararg{Any, 5}}" href="#Muspel._read_broadening_single-Tuple{Dict, Vararg{Any, 5}}"><code>Muspel._read_broadening_single</code></a> â€” <span class="docstring-category">Method</span></header><section><div><p>Reads individual broadening mechanisms and converts each to a multiplier constant and temperature exponent based on different recipes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tiagopereira/Muspel.jl/blob/407440565a4b0a3d62bbb9a899c2b292dbb41b7c/src/read_utils.jl#L315-L318">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Muspel._read_transition-Tuple{Dict, Any, Any}" href="#Muspel._read_transition-Tuple{Dict, Any, Any}"><code>Muspel._read_transition</code></a> â€” <span class="docstring-category">Method</span></header><section><div><p>Helper function to parse transition upper and lower levels and compute wavelength. To be used with fields from the YAML atom format.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tiagopereira/Muspel.jl/blob/407440565a4b0a3d62bbb9a899c2b292dbb41b7c/src/read_utils.jl#L240-L243">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Muspel._spline_coeffs-Tuple{Any, Any}" href="#Muspel._spline_coeffs-Tuple{Any, Any}"><code>Muspel._spline_coeffs</code></a> â€” <span class="docstring-category">Method</span></header><section><div><p>Computes coefficients for cubic spline interpolation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tiagopereira/Muspel.jl/blob/407440565a4b0a3d62bbb9a899c2b292dbb41b7c/src/incline.jl#L203-L205">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Muspel._spline_stencil-Tuple{Any, Any, Any}" href="#Muspel._spline_stencil-Tuple{Any, Any, Any}"><code>Muspel._spline_stencil</code></a> â€” <span class="docstring-category">Method</span></header><section><div><p>Gets stencil coordinates for cubic spline.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tiagopereira/Muspel.jl/blob/407440565a4b0a3d62bbb9a899c2b292dbb41b7c/src/incline.jl#L226-L228">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Muspel._w2-Tuple{T} where T&lt;:AbstractFloat" href="#Muspel._w2-Tuple{T} where T&lt;:AbstractFloat"><code>Muspel._w2</code></a> â€” <span class="docstring-category">Method</span></header><section><div><p>Computes weights for linear integration of source function, approximating <code>exp(-Î”Ï„)</code> for very small and very large values of <code>Î”Ï„</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tiagopereira/Muspel.jl/blob/407440565a4b0a3d62bbb9a899c2b292dbb41b7c/src/formal_solvers.jl#L234-L237">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Muspel.blackbody_Î»-Union{Tuple{T2}, Tuple{T1}, Tuple{T1, T2}} where {T1&lt;:Real, T2&lt;:AbstractFloat}" href="#Muspel.blackbody_Î»-Union{Tuple{T2}, Tuple{T1}, Tuple{T1, T2}} where {T1&lt;:Real, T2&lt;:AbstractFloat}"><code>Muspel.blackbody_Î»</code></a> â€” <span class="docstring-category">Method</span></header><section><div><p>Calculates the Blackbody (Planck) function per wavelength in nm and temperature in K. Outputs in kW m^-2 nm^-1.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tiagopereira/Muspel.jl/blob/407440565a4b0a3d62bbb9a899c2b292dbb41b7c/src/utils.jl#L5-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Muspel.calc_line_1D!-Union{Tuple{T}, Tuple{AtomicLine, RTBuffer{T}, Atmosphere1D{1, T, A, V} where {A&lt;:AbstractVector{T}, V&lt;:AbstractVector{T}}, AbstractVector{T}, AbstractVector{T}, ExtinctionItpNLTE{var&quot;#s38&quot;, T2, ITP_2D, ITP_1D} where {var&quot;#s38&quot;&lt;:Real, T2, ITP_2D&lt;:(Interpolations.AbstractInterpolation{var&quot;#s38&quot;, 2}), ITP_1D&lt;:(Interpolations.AbstractInterpolation{var&quot;#s38&quot;, 1})}, Interpolations.AbstractInterpolation{&lt;:Real, 2}}} where T&lt;:AbstractFloat" href="#Muspel.calc_line_1D!-Union{Tuple{T}, Tuple{AtomicLine, RTBuffer{T}, Atmosphere1D{1, T, A, V} where {A&lt;:AbstractVector{T}, V&lt;:AbstractVector{T}}, AbstractVector{T}, AbstractVector{T}, ExtinctionItpNLTE{var&quot;#s38&quot;, T2, ITP_2D, ITP_1D} where {var&quot;#s38&quot;&lt;:Real, T2, ITP_2D&lt;:(Interpolations.AbstractInterpolation{var&quot;#s38&quot;, 2}), ITP_1D&lt;:(Interpolations.AbstractInterpolation{var&quot;#s38&quot;, 1})}, Interpolations.AbstractInterpolation{&lt;:Real, 2}}} where T&lt;:AbstractFloat"><code>Muspel.calc_line_1D!</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function calc_line_1D!(
    line::AtomicLine,
    buf::RTBuffer{T},
    atm::Atmosphere1D{T},
    n_up::AbstractVector{T},
    n_lo::AbstractVector{T},
    Ïƒ_itp::ExtinctionItpNLTE{&lt;:Real},
    voigt_itp::Interpolations.AbstractInterpolation{&lt;:Real, 2},
)</code></pre><p>Calculate emerging disk-centre intensity for a given line in a 1D atmosphere.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tiagopereira/Muspel.jl/blob/407440565a4b0a3d62bbb9a899c2b292dbb41b7c/src/intensity.jl#L4-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Muspel.calc_Î»line_MULTI-Union{Tuple{T}, Tuple{Union{Unitful.Quantity{T, ð‹, U}, Unitful.Level{L, S, Unitful.Quantity{T, ð‹, U}} where {L, S}} where U, Any, T, T, Union{Unitful.Quantity{T, ð‹ ð“^-1, U}, Unitful.Level{L, S, Unitful.Quantity{T, ð‹ ð“^-1, U}} where {L, S}} where U}} where T&lt;:Real" href="#Muspel.calc_Î»line_MULTI-Union{Tuple{T}, Tuple{Union{Unitful.Quantity{T, ð‹, U}, Unitful.Level{L, S, Unitful.Quantity{T, ð‹, U}} where {L, S}} where U, Any, T, T, Union{Unitful.Quantity{T, ð‹ ð“^-1, U}, Unitful.Level{L, S, Unitful.Quantity{T, ð‹ ð“^-1, U}} where {L, S}} where U}} where T&lt;:Real"><code>Muspel.calc_Î»line_MULTI</code></a> â€” <span class="docstring-category">Method</span></header><section><div><p>Calculate line wavelengths using recipe from MULTI.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tiagopereira/Muspel.jl/blob/407440565a4b0a3d62bbb9a899c2b292dbb41b7c/src/read_utils.jl#L188-L190">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Muspel.calc_Î»line_RH-Union{Tuple{T}, Tuple{Union{Unitful.Quantity{T, ð‹, U}, Unitful.Level{L, S, Unitful.Quantity{T, ð‹, U}} where {L, S}} where U, Any, T, T, Union{Unitful.Quantity{T, ð‹ ð“^-1, U}, Unitful.Level{L, S, Unitful.Quantity{T, ð‹ ð“^-1, U}} where {L, S}} where U}} where T&lt;:Real" href="#Muspel.calc_Î»line_RH-Union{Tuple{T}, Tuple{Union{Unitful.Quantity{T, ð‹, U}, Unitful.Level{L, S, Unitful.Quantity{T, ð‹, U}} where {L, S}} where U, Any, T, T, Union{Unitful.Quantity{T, ð‹ ð“^-1, U}, Unitful.Level{L, S, Unitful.Quantity{T, ð‹ ð“^-1, U}} where {L, S}} where U}} where T&lt;:Real"><code>Muspel.calc_Î»line_RH</code></a> â€” <span class="docstring-category">Method</span></header><section><div><p>Calculate line wavelengths using recipe from RH.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tiagopereira/Muspel.jl/blob/407440565a4b0a3d62bbb9a899c2b292dbb41b7c/src/read_utils.jl#L160-L162">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Muspel.create_Ïƒ_itp_LTE-Union{Tuple{T}, Tuple{Real, AbstractRange{T}, AbstractRange{T}, AtomicModel, AbstractVector{AtomicModel}, Vector{Vector{Interpolations.FilledExtrapolation}}}} where T&lt;:Real" href="#Muspel.create_Ïƒ_itp_LTE-Union{Tuple{T}, Tuple{Real, AbstractRange{T}, AbstractRange{T}, AtomicModel, AbstractVector{AtomicModel}, Vector{Vector{Interpolations.FilledExtrapolation}}}} where T&lt;:Real"><code>Muspel.create_Ïƒ_itp_LTE</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">create_Ïƒ_itp_LTE(
    Î»::T,
    log_temp::AbstractVector{T},
    log_ne::AbstractVector{T},
    H_atom::AtomicModel,
    background_atoms::AbstractVector{AtomicModel},
    atom_interpolants::Vector{Vector{Interpolations.FilledExtrapolation}},
)</code></pre><p>Create interpolant structure continuum cross section, for the case when hydrogen populations are not given explicitly (and are calculated using Saha). Includes cross sections from bound-free transition present in background atoms, plus the following sources of extinction:</p><pre><code class="nohighlight hljs">* sources from ÏƒH_continuum
* H ff</code></pre><p><strong>Arguments</strong></p><ul><li><code>Î»</code>: wavelength in nm.</li><li><code>log_temp</code>: sequence of log10 temperature (K) for the table.</li><li><code>log_ne</code>: sequence of log10 electron density (m^-3) for the table.</li><li><code>H_atom</code>: a hydrogen model atom to compute Saha ionisation fractions</li><li><code>background_atoms</code> : sequence of model atoms</li><li><code>atom_interpolants</code> : sequence of bf interpolants corresponding to each background atom</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tiagopereira/Muspel.jl/blob/407440565a4b0a3d62bbb9a899c2b292dbb41b7c/src/background.jl#L390-L415">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Muspel.create_Ïƒ_itp_NLTE-Union{Tuple{T}, Tuple{Real, AbstractRange{T}, AbstractRange{T}, AbstractVector{AtomicModel}, Vector{Vector{Interpolations.FilledExtrapolation}}}} where T&lt;:Real" href="#Muspel.create_Ïƒ_itp_NLTE-Union{Tuple{T}, Tuple{Real, AbstractRange{T}, AbstractRange{T}, AbstractVector{AtomicModel}, Vector{Vector{Interpolations.FilledExtrapolation}}}} where T&lt;:Real"><code>Muspel.create_Ïƒ_itp_NLTE</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">create_Ïƒ_itp_NLTE(
    Î»::Real,
    log_temp::AbstractVector{T},
    log_ne::AbstractVector{T},
    background_atoms::AbstractVector{AtomicModel},
    atom_interpolants::Vector{Vector{Interpolations.FilledExtrapolation}},
)</code></pre><p>Create interpolant structure continuum cross section, for the case of explicit hydrogen populations. Includes cross sections from bound-free transition present in background atoms, plus the following sources of extinction:</p><ul><li>Hminus bf and ff</li><li>H2+ molecule bf and ff</li><li>H ff</li></ul><p><strong>Arguments</strong></p><ul><li><code>Î»</code>: wavelength in nm.</li><li><code>log_temp</code>: sequence of log10 temperature (K) for the table.</li><li><code>log_ne</code>: sequence of log10 electron density (m^-3) for the table.</li><li><code>background_atoms</code> : sequence of model atoms</li><li><code>atom_interpolants</code> : sequence of bf interpolants corresponding to each background atom</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tiagopereira/Muspel.jl/blob/407440565a4b0a3d62bbb9a899c2b292dbb41b7c/src/background.jl#L446-L469">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Muspel.damping-Union{Tuple{T}, Tuple{T, Real, Real}} where T&lt;:Real" href="#Muspel.damping-Union{Tuple{T}, Tuple{T, Real, Real}} where T&lt;:Real"><code>Muspel.damping</code></a> â€” <span class="docstring-category">Method</span></header><section><div><p>Damping constant for Î³ in rad / s, Î» and Î”Î»D in nm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tiagopereira/Muspel.jl/blob/407440565a4b0a3d62bbb9a899c2b292dbb41b7c/src/line.jl#L14-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Muspel.doppler_width-Union{Tuple{T}, Tuple{Any, Any, T}} where T&lt;:AbstractFloat" href="#Muspel.doppler_width-Union{Tuple{T}, Tuple{Any, Any, T}} where T&lt;:AbstractFloat"><code>Muspel.doppler_width</code></a> â€” <span class="docstring-category">Method</span></header><section><div><p>Doppler width for mass in kg, temperature in K</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tiagopereira/Muspel.jl/blob/407440565a4b0a3d62bbb9a899c2b292dbb41b7c/src/line.jl#L6-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Muspel.feautrier-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, AbstractVector{T}}} where T&lt;:AbstractFloat" href="#Muspel.feautrier-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, AbstractVector{T}}} where T&lt;:AbstractFloat"><code>Muspel.feautrier</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function feautrier(
    z::Array{&lt;:Unitful.Length{T}, 1},
    Î±::Array{&lt;:PerLength{T}, 1},
    source_function::Array{&lt;:Unitful.Quantity, 1}
) where T &lt;: AbstractFloat</code></pre><p>Calculate solution to radiative transfer equation using the Feautrier method. Uses algorithm from <a href="https://ui.adsabs.harvard.edu/abs/1991A&amp;A...245..171R">Rybicki &amp; Hummer, 1991, A&amp;A 245</a>. Returns the height-dependent Feautrier variable <code>P</code>:</p><p class="math-container">\[P \equiv 1/2 (I^+ + I^-)\]</p><p>Currently operates under the following assumptions:</p><ul><li>The first index of the variables is the top of the atmosphere</li><li>The boundary conditions are zero radiation at the top and source function at the bottom</li></ul><p>Therefore, the emergent intensity is <code>2 * P[1]</code>, since <span>$I^-[1]=0$</span>.</p><p>Not properly tested, use with care!</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tiagopereira/Muspel.jl/blob/407440565a4b0a3d62bbb9a899c2b292dbb41b7c/src/formal_solvers.jl#L173-L195">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Muspel.get_atoms_bf_interpolant-Tuple{AbstractVector{AtomicModel}}" href="#Muspel.get_atoms_bf_interpolant-Tuple{AbstractVector{AtomicModel}}"><code>Muspel.get_atoms_bf_interpolant</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_atoms_bf_interpolant(atoms::AbstractVector{AtomicModel})</code></pre><p>Returns interpolants for bound-free cross section data multiplied with abundances for each atom.</p><p><strong>Arguments</strong></p><ul><li><code>atoms</code>: A Vector of AtomicModels, with continua.</li></ul><p><strong>Returns</strong></p><ul><li><code>tables::Vector{Vector{Interpolations.FilledExtrapolation}}</code>:   Interpolation functions.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; ATOM_PATH = &quot;/my/atoms/dir/&quot;;
julia&gt; atoms = [
    &quot;Al.yaml&quot;,
    &quot;C.yaml&quot;,
    &quot;Ca.yaml&quot;,
    &quot;Fe.yaml&quot;,
    &quot;H_6.yaml&quot;,
    &quot;He.yaml&quot;,
    &quot;KI.yaml&quot;,
    &quot;Mg.yaml&quot;,
    &quot;N.yaml&quot;,
    &quot;Na.yaml&quot;,
    &quot;NiI.yaml&quot;,
    &quot;O.yaml&quot;,
    &quot;S.yaml&quot;,
    &quot;Si.yaml&quot;,
];
julia&gt; background_atoms = Vector{AtomicModel}(undef, length(atoms))
julia&gt; for (index, atom_file) in enumerate(atoms)
           background_atoms[index] = read_atom(join([ATOM_PATH, atom_file]))
       end
julia&gt; atom_interpolants = get_atoms_bf_interpolant(background_atoms);</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tiagopereira/Muspel.jl/blob/407440565a4b0a3d62bbb9a899c2b292dbb41b7c/src/background.jl#L333-L371">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Muspel.get_Ïƒ_itp-Tuple{Muspel.AbstractAtmos, Real, Vector{String}}" href="#Muspel.get_Ïƒ_itp-Tuple{Muspel.AbstractAtmos, Real, Vector{String}}"><code>Muspel.get_Ïƒ_itp</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_Ïƒ_itp(atmos::Atmosphere, Î»::Real, atom_files::Vector{String}; npts=100)</code></pre><p>Construct monochromatic continuum cross section interpolant for a given atmosphere, and wavelength Î» in nm. Includes all the processes included in <code>create_Ïƒ_itp_NLTE</code>, plus all the bound-free cross sections present in all model atom files in the list <code>atom_files</code>.</p><p>Here <code>atmos</code> is used only to get the minimum and maximum values of temperature and electron density, to build the interpolation table. The number of points in the table (both for log(temperature) and log(electron density)) is given by <code>npts</code> (default 100).</p><p><strong>Returns</strong></p><ul><li>ExtinctionItpNLTE: continuum cross section interpolant for explicit hydrogen populations. To be used in function <code>Î±_cont</code>.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; ATOM_PATH = AtomicData.get_atom_dir();
julia&gt; bckgr_atoms = [
    &quot;Al.yaml&quot;,
    &quot;C.yaml&quot;,
    &quot;Ca.yaml&quot;,
    &quot;Fe.yaml&quot;,
    &quot;H_6.yaml&quot;,
    &quot;He.yaml&quot;,
    &quot;KI.yaml&quot;,
    &quot;Mg.yaml&quot;,
    &quot;N.yaml&quot;,
    &quot;Na.yaml&quot;,
    &quot;NiI.yaml&quot;,
    &quot;O.yaml&quot;,
    &quot;S.yaml&quot;,
    &quot;Si.yaml&quot;,
];
julia&gt; atom_files = [joinpath(ATOM_PATH, a) for a in bckgr_atoms];
julia&gt; atmos = atmos = read_atmos_rh(MY_ATMOS);
julia&gt; itp = get_Ïƒ_itp(atmos, 500.0, atom_files)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tiagopereira/Muspel.jl/blob/407440565a4b0a3d62bbb9a899c2b292dbb41b7c/src/background.jl#L272-L312">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Muspel.h_ionfrac_saha-Union{Tuple{T}, Tuple{T, Real}} where T&lt;:Real" href="#Muspel.h_ionfrac_saha-Union{Tuple{T}, Tuple{T, Real}} where T&lt;:Real"><code>Muspel.h_ionfrac_saha</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">h_ionfrac_saha(temp::T, electron_density::T)::T where {T &lt;: Real}</code></pre><p>Calculate ionisation fraction of hydrogen using Saha.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tiagopereira/Muspel.jl/blob/407440565a4b0a3d62bbb9a899c2b292dbb41b7c/src/lte.jl#L149-L153">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Muspel.incline_atmos-Tuple{Muspel.AbstractAtmos3D, Real, Real}" href="#Muspel.incline_atmos-Tuple{Muspel.AbstractAtmos3D, Real, Real}"><code>Muspel.incline_atmos</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">incline_atmos(atmos_in::AbstractAtmos3D, Î¼::Real, Ï†::Real)</code></pre><p>Transforms a 3D atmosphere into an inclined coordinate system, given by a rotation by a polar angle Î¸, given by Î¼ = cos(Î¸) and an azimuthal angle Ï†. The output is an atmosphere of the same type, where the quantities have been interpolated to the same number of depth points and the vector quantities projected onto the new axes.</p><p>Assumes the following:</p><ol><li>Order of the axes in 3D arrays is (z, y, x)</li><li>Horizontally periodic boundary conditions</li><li>The first index in the height direction is fixed in the polar rotation</li><li>A right handed system, so that:</li></ol><pre><code class="nohighlight hljs">      z â†‘.            - Î¸ is the clockwise polar rotation from the z axis
        |  .          - Ï† is the clockwise azimuthal rotation from the x axis
        |    .
        |      .
        |        *
        |      . .
        | Î¸  .   .
        |  .     .
        |.       .
        +--------.-----â†’ y
       /  .      .   /
      /  Ï†  .    .
     /         . . /
    /- - - - - - .
  x</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tiagopereira/Muspel.jl/blob/407440565a4b0a3d62bbb9a899c2b292dbb41b7c/src/incline.jl#L5-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Muspel.incline_data!-Tuple{AbstractArray{&lt;:Real, 3}, AbstractVector, Vararg{Real, 4}}" href="#Muspel.incline_data!-Tuple{AbstractArray{&lt;:Real, 3}, AbstractVector, Vararg{Real, 4}}"><code>Muspel.incline_data!</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">incline_data!(
        data::AbstractArray{&lt;: Real, 3},
        z::AbstractVector,
        dx::Real,
        dy::Real,
        Î¼::Real,
        Ï•::Real
)</code></pre><p>Transforms a 3D array into an inclined coordinate system, according to a polar angle given by Î¼ = cos(Î¸), and an azimuthal angle Ï•. Uses cubic spline interpolation, and updates <code>data</code> in-place.</p><p>This version only works if height is the first dimension in <code>data</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tiagopereira/Muspel.jl/blob/407440565a4b0a3d62bbb9a899c2b292dbb41b7c/src/incline.jl#L174-L189">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Muspel.incline_data_inv!-Tuple{AbstractArray{&lt;:Real, 3}, AbstractVector, Vararg{Real, 4}}" href="#Muspel.incline_data_inv!-Tuple{AbstractArray{&lt;:Real, 3}, AbstractVector, Vararg{Real, 4}}"><code>Muspel.incline_data_inv!</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">incline_data_inv!(
        data::AbstractArray{&lt;: Real, 3},
        z::AbstractVector,
        dx::Real,
        dy::Real,
        Î¼::Real,
        Ï•::Real
)</code></pre><p>Transforms a 3D array into an inclined coordinate system, according to a polar angle given by Î¼ = cos(Î¸), and an azimuthal angle Ï•. Uses cubic spline interpolation, and updates <code>data</code> in-place. Based on trnslt.f90 from Ã…ke Nordlund.</p><p>This version only works if height is the last dimension in <code>data</code>. This is 3-5x faster than <code>incline_data!</code> because the loop order is optimised for this memory configuration.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tiagopereira/Muspel.jl/blob/407440565a4b0a3d62bbb9a899c2b292dbb41b7c/src/incline.jl#L104-L122">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Muspel.piecewise_1D_linear!-Union{Tuple{T}, NTuple{4, AbstractVector{T}}} where T&lt;:AbstractFloat" href="#Muspel.piecewise_1D_linear!-Union{Tuple{T}, NTuple{4, AbstractVector{T}}} where T&lt;:AbstractFloat"><code>Muspel.piecewise_1D_linear!</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">piecewise_1D_linear!(
    z::AbstractVector{T},
    Î±::AbstractVector{T},
    source_function::AbstractVector{T},
    intensity::AbstractVector{T};
    to_end::Bool=false,
    initial_condition=:source
) where T &lt;: AbstractFloat</code></pre><p>Compute piecewise integration of the radiative transfer equation, assuming linear integration of the source function, for a given height <code>z</code>, extinction <code>Î±</code> and <code>source_function</code> and <code>intensity</code> (existing array where the output will be saved into). The optional keyword argument <code>to_end</code> defines the direction of the integration: if <code>false</code> (default) will start to integrate intensity from the last element to the first, and if <code>true</code> will integrate from the first element to the last. <code>initial_condition</code> can take two values: <code>:zero</code> for no radiation, or <code>:source</code> (default) to take the source function at the starting point.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tiagopereira/Muspel.jl/blob/407440565a4b0a3d62bbb9a899c2b292dbb41b7c/src/formal_solvers.jl#L115-L135">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Muspel.piecewise_1D_linear-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, AbstractVector{T}}} where T&lt;:AbstractFloat" href="#Muspel.piecewise_1D_linear-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, AbstractVector{T}}} where T&lt;:AbstractFloat"><code>Muspel.piecewise_1D_linear</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">piecewise_1D_linear(
    z::AbstractVector{T},
    Î±::AbstractVector{T},
    source_function::AbstractVector{T};
    to_end::Bool=false,
    initial_condition=:source
) where T &lt;: AbstractFloat</code></pre><p>DEPRECATED, use piecewise<em>1D</em>linear! Compute piecewise integration of the radiative transfer equation, assuming linear integration of the source function, for a given height <code>z</code>, extinction <code>Î±</code> and <code>source_function</code>. The optional keyword argument <code>to_end</code> defines the direction of the integration: if <code>false</code> (default) will start to integrate intensity from the last element to the first, and if <code>true</code> will integrate from the first element to the last. <code>initial_condition</code> can take two values: <code>:zero</code> for no radiation, or <code>:source</code> (default) to take the source function at the starting point.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tiagopereira/Muspel.jl/blob/407440565a4b0a3d62bbb9a899c2b292dbb41b7c/src/formal_solvers.jl#L60-L79">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Muspel.piecewise_1D_nn-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, AbstractVector{T}}} where T&lt;:AbstractFloat" href="#Muspel.piecewise_1D_nn-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, AbstractVector{T}}} where T&lt;:AbstractFloat"><code>Muspel.piecewise_1D_nn</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">piecewise_1D_nn(
    z::AbstractVector{T},
    Î±::AbstractVector{T},
    source_function::AbstractVector{T};
    to_end::Bool=false,
    initial_condition=:source
) where T &lt;: AbstractFloat</code></pre><p>Compute piecewise integration of the radiative transfer equation, assuming nearest-neighbour integration of the source function, for a given height <code>z</code>, extinction <code>Î±</code> and <code>source_function</code>. The optional keyword argument <code>to_end</code> defines the direction of the integration: if <code>false</code> (default) will start to integrate intensity from the last element to the first, and if <code>true</code> will integrate from the first element to the last. <code>initial_condition</code> can take two values: <code>:zero</code> for no radiation, or <code>:source</code> (default) to take the source function at the starting point.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tiagopereira/Muspel.jl/blob/407440565a4b0a3d62bbb9a899c2b292dbb41b7c/src/formal_solvers.jl#L6-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Muspel.project_vector!-Union{Tuple{A}, Tuple{A, A, A, Real, Real}} where A&lt;:(AbstractArray{&lt;:Real})" href="#Muspel.project_vector!-Union{Tuple{A}, Tuple{A, A, A, Real, Real}} where A&lt;:(AbstractArray{&lt;:Real})"><code>Muspel.project_vector!</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">project_vector!(vx::A, vy::A, vz::A, Î¼::Real, Ï†::Real)</code></pre><p>Projects a vector in 3D space according to the rotation by an polar angle Î¸, given by Î¼ = cos(Î¸) and an azimuthal angle Ï†. The inputs are the vector components in the x, y, and z axes, for an array of a given size (typically 3D).</p><p>Assumes the following:</p><ol><li>Î¸ is the clockwise polar rotation from the z axis</li><li>Ï† is the clockwise azimuthal rotation from the x axis</li><li>The rotation of the vector is the same as the rotation from the axes (x, y, z) into a new system (x&#39;, y&#39;, z&#39;) given by the rotation matrix:</li></ol><pre><code class="nohighlight hljs">               Polar          Azimuthal
   âŽ¡x&#39;âŽ¤ = âŽ¡cosÎ¸  0  -sinÎ¸âŽ¤âŽ¡ cosÏ†  sinÏ†  0âŽ¤âŽ¡xâŽ¤
   âŽœy&#39;âŽ¥   âŽœ  0   1    0  âŽ¥âŽœ-sinÏ†  cosÏ†  0âŽ¥âŽœyâŽ¥
   âŽ£z&#39;âŽ¦   âŽ£sinÎ¸  0   cosÎ¸âŽ¦âŽ£   0     0   1âŽ¦âŽ£zâŽ¦

   âŒˆx&#39;âŽ¤ = âŽ¡cosÎ¸cosÏ†  cosÎ¸sinÏ†  -sinÏ†âŽ¤âŽ¡xâŽ¤
   |y&#39;âŽ¥   âŽœ -sinÏ†      cosÏ†       0 âŽ¥âŽœyâŽ¥
   âŒŠz&#39;âŽ¦   âŽ£sinÎ¸cosÏ†  sinÎ¸sinÏ†   cosÎ¸âŽ¦âŽ£zâŽ¦</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tiagopereira/Muspel.jl/blob/407440565a4b0a3d62bbb9a899c2b292dbb41b7c/src/incline.jl#L61-L86">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Muspel.read_atmos_hpops_multi3d-Tuple{Any, Any, Any}" href="#Muspel.read_atmos_hpops_multi3d-Tuple{Any, Any, Any}"><code>Muspel.read_atmos_hpops_multi3d</code></a> â€” <span class="docstring-category">Method</span></header><section><div><p>Reads atmosphere in the input format of MULTI3D, at the same time as the hydrogen populations. Only works for a H NLTE run.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tiagopereira/Muspel.jl/blob/407440565a4b0a3d62bbb9a899c2b292dbb41b7c/src/read_atmos.jl#L175-L178">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Muspel.read_atmos_hpops_rh-Tuple{Any, Any}" href="#Muspel.read_atmos_hpops_rh-Tuple{Any, Any}"><code>Muspel.read_atmos_hpops_rh</code></a> â€” <span class="docstring-category">Method</span></header><section><div><p>Reads RH atmosphere. Returns always in single precision.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tiagopereira/Muspel.jl/blob/407440565a4b0a3d62bbb9a899c2b292dbb41b7c/src/read_atmos.jl#L57-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Muspel.read_atmos_multi3d-Tuple{Any, Any}" href="#Muspel.read_atmos_multi3d-Tuple{Any, Any}"><code>Muspel.read_atmos_multi3d</code></a> â€” <span class="docstring-category">Method</span></header><section><div><p>Reads atmosphere in the input format of MULTI3D.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tiagopereira/Muspel.jl/blob/407440565a4b0a3d62bbb9a899c2b292dbb41b7c/src/read_atmos.jl#L107-L109">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Muspel.read_atmos_rh-Tuple{Any}" href="#Muspel.read_atmos_rh-Tuple{Any}"><code>Muspel.read_atmos_rh</code></a> â€” <span class="docstring-category">Method</span></header><section><div><p>Reads RH atmosphere. Returns always in single precision.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tiagopereira/Muspel.jl/blob/407440565a4b0a3d62bbb9a899c2b292dbb41b7c/src/read_atmos.jl#L11-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Muspel.read_atom-Tuple{Any}" href="#Muspel.read_atom-Tuple{Any}"><code>Muspel.read_atom</code></a> â€” <span class="docstring-category">Method</span></header><section><div><p>Reads atom in YAML format, returns AtomicModel structure</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tiagopereira/Muspel.jl/blob/407440565a4b0a3d62bbb9a899c2b292dbb41b7c/src/read_utils.jl#L6-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Muspel.read_continuum-Tuple{Dict, Any, Any, Any}" href="#Muspel.read_continuum-Tuple{Dict, Any, Any, Any}"><code>Muspel.read_continuum</code></a> â€” <span class="docstring-category">Method</span></header><section><div><p>Reads continuum transition data in a Dict read from a YAML-formatted atom file. Needs level energies Ï‡, ionisation stages, and level ids from atom file.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tiagopereira/Muspel.jl/blob/407440565a4b0a3d62bbb9a899c2b292dbb41b7c/src/read_utils.jl#L53-L56">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Muspel.read_line-Tuple{Dict, Vararg{Any, 6}}" href="#Muspel.read_line-Tuple{Dict, Vararg{Any, 6}}"><code>Muspel.read_line</code></a> â€” <span class="docstring-category">Method</span></header><section><div><p>Reads spectral line data in a Dict read from a YAML-formatted atom file. Needs level energies Ï‡, ionisation stages, labels, level ids and atomic mass from atom file.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tiagopereira/Muspel.jl/blob/407440565a4b0a3d62bbb9a899c2b292dbb41b7c/src/read_utils.jl#L86-L90">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Muspel.read_mesh-Tuple{Any}" href="#Muspel.read_mesh-Tuple{Any}"><code>Muspel.read_mesh</code></a> â€” <span class="docstring-category">Method</span></header><section><div><p>Reads mesh file from Bifrost or MULTI3D.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tiagopereira/Muspel.jl/blob/407440565a4b0a3d62bbb9a899c2b292dbb41b7c/src/read_atmos.jl#L266-L268">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Muspel.read_pops_multi3d-NTuple{5, Any}" href="#Muspel.read_pops_multi3d-NTuple{5, Any}"><code>Muspel.read_pops_multi3d</code></a> â€” <span class="docstring-category">Method</span></header><section><div><p>Reads NLTE populations from MULTI3D output. Does NOT permute dims.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tiagopereira/Muspel.jl/blob/407440565a4b0a3d62bbb9a899c2b292dbb41b7c/src/read_atmos.jl#L252-L254">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Muspel.read_pops_rh-Tuple{Any, Any}" href="#Muspel.read_pops_rh-Tuple{Any, Any}"><code>Muspel.read_pops_rh</code></a> â€” <span class="docstring-category">Method</span></header><section><div><p>Reads array with populations for a given species.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tiagopereira/Muspel.jl/blob/407440565a4b0a3d62bbb9a899c2b292dbb41b7c/src/read_atmos.jl#L89-L91">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Muspel.saha_boltzmann!-Union{Tuple{T}, Tuple{N}, Tuple{StaticArraysCore.SVector{N, &lt;:Real}, StaticArraysCore.SVector{N, &lt;:Real}, StaticArraysCore.SVector{N, &lt;:Real}, Real, Real, Real, AbstractVector{T}}} where {N, T&lt;:AbstractFloat}" href="#Muspel.saha_boltzmann!-Union{Tuple{T}, Tuple{N}, Tuple{StaticArraysCore.SVector{N, &lt;:Real}, StaticArraysCore.SVector{N, &lt;:Real}, StaticArraysCore.SVector{N, &lt;:Real}, Real, Real, Real, AbstractVector{T}}} where {N, T&lt;:AbstractFloat}"><code>Muspel.saha_boltzmann!</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function saha_boltzmann!(
    Ï‡::SVector,
    g::SVector,
    stage::SVector,
    temperature::T,
    electron_density::T,
    atom_density::T,
    populations::AbstractArray{T, 1},
) where T &lt;: AbstractFloat

function saha_boltzmann!(
    atom::AtomicModel,
    temperature::T,
    electron_density::T,
    atom_density::T,
    populations::AbstractArray{T, 1},
) where T &lt;: AbstractFloat</code></pre><p>Inplace version of <code>saha_boltzmann</code><code>. Calculates atomic level populations according to the Saha-Boltzmann distribution, placing them in an existing</code>populations` array.</p><p><strong>Arguments</strong></p><ul><li><code>Ï‡</code>: level energies in J</li><li><code>g</code>: statistical weights of levels</li><li><code>stage</code>: ionisation stage of each level (starting at 1 for neutral)</li><li>Or, instead of the three above, an instance of <code>AtomicModel</code></li><li><code>temperature</code>: temperature in Kelvin</li><li><code>electron_density</code>: electron density in m^-3</li><li><code>atom_density</code>: total number density (in all levels) of target species</li><li><code>populations</code>: 1D array for output, must be same length as number of levels</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tiagopereira/Muspel.jl/blob/407440565a4b0a3d62bbb9a899c2b292dbb41b7c/src/lte.jl#L65-L97">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Muspel.saha_boltzmann-Union{Tuple{T}, Tuple{N}, Tuple{StaticArraysCore.SVector{N, &lt;:Real}, StaticArraysCore.SVector{N, &lt;:Real}, StaticArraysCore.SVector{N, &lt;:Real}, T, T, Real}} where {N, T&lt;:AbstractFloat}" href="#Muspel.saha_boltzmann-Union{Tuple{T}, Tuple{N}, Tuple{StaticArraysCore.SVector{N, &lt;:Real}, StaticArraysCore.SVector{N, &lt;:Real}, StaticArraysCore.SVector{N, &lt;:Real}, T, T, Real}} where {N, T&lt;:AbstractFloat}"><code>Muspel.saha_boltzmann</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function saha_boltzmann(
    Ï‡::SVector,
    g::SVector,
    stage::SVector,
    temperature::T,
    electron_density::T,
    atom_density::T
) where T &lt;: AbstractFloat

function saha_boltzmann(
    atom::AtomicModel,
    temperature::T,
    electron_density::T,
    atom_density::T,
) where T &lt;: AbstractFloat</code></pre><p>Calculates atomic level populations according to the Saha-Boltzmann distribution.</p><p><strong>Arguments</strong></p><ul><li><code>Ï‡</code>: level energies in J</li><li><code>g</code>: statistical weights of levels</li><li><code>stage</code>: ionisation stage of each level (starting at 1 for neutral)</li><li>Or, instead of the three above, an instance of <code>AtomicModel</code></li><li><code>temperature</code>: temperature in Kelvin</li><li><code>electron_density</code>: electron density in m^-3</li><li><code>atom_density</code>: total number density (in all levels) of target species</li></ul><p><strong>Returns</strong></p><ul><li><code>populations</code>: MVector{nlevels} with relative level populations in m^-3</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tiagopereira/Muspel.jl/blob/407440565a4b0a3d62bbb9a899c2b292dbb41b7c/src/lte.jl#L10-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Muspel.Î±_cont-Union{Tuple{T}, Tuple{ExtinctionItpLTE{var&quot;#s42&quot;, T2, ITP_2D} where {var&quot;#s42&quot;&lt;:Real, T2, ITP_2D&lt;:(Interpolations.AbstractInterpolation{var&quot;#s42&quot;, 2})}, T, T, T}} where T&lt;:AbstractFloat" href="#Muspel.Î±_cont-Union{Tuple{T}, Tuple{ExtinctionItpLTE{var&quot;#s42&quot;, T2, ITP_2D} where {var&quot;#s42&quot;&lt;:Real, T2, ITP_2D&lt;:(Interpolations.AbstractInterpolation{var&quot;#s42&quot;, 2})}, T, T, T}} where T&lt;:AbstractFloat"><code>Muspel.Î±_cont</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Î±_cont(
    itp::ExtinctionItpLTE{T},
    temperature::T,
    electron_density::T,
    hydrogen_density::T,
)</code></pre><p>Calculates continuum extinction in m^-1 using interpolant structure.</p><p><strong>Arguments</strong></p><ul><li><code>itp</code>: Interpolant structure for a given wavelength, hydrogen LTE case</li><li><code>temperature</code>: Temperature in K.</li><li><code>electron_density</code>: Electron number density in m^-3.</li><li><code>hydrogen_density</code>: Number density of hydrogen atoms (all stages), unit m^-3.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; npts = 100;
julia&gt; log_temp = LinRange(3.3, 5, npts);
julia&gt; log_ne = LinRange(15, 23, npts);
julia&gt; H_3 = read_atom(&quot;H_3.yaml&quot;);
julia&gt; itp_lte = create_Ïƒ_itp_LTE(500., log_temp, log_ne, H_3,
                                  background_atoms, atom_interpolants);
julia&gt; Î±_cont(itp_lte, 6000., 1e20, 1e20)
3.59972810095902e-8</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tiagopereira/Muspel.jl/blob/407440565a4b0a3d62bbb9a899c2b292dbb41b7c/src/background.jl#L55-L82">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Muspel.Î±_cont-Union{Tuple{T}, Tuple{ExtinctionItpNLTE{var&quot;#s42&quot;, T2, ITP_2D, ITP_1D} where {var&quot;#s42&quot;&lt;:Real, T2, ITP_2D&lt;:(Interpolations.AbstractInterpolation{var&quot;#s42&quot;, 2}), ITP_1D&lt;:(Interpolations.AbstractInterpolation{var&quot;#s42&quot;, 1})}, Vararg{T, 4}}} where T&lt;:AbstractFloat" href="#Muspel.Î±_cont-Union{Tuple{T}, Tuple{ExtinctionItpNLTE{var&quot;#s42&quot;, T2, ITP_2D, ITP_1D} where {var&quot;#s42&quot;&lt;:Real, T2, ITP_2D&lt;:(Interpolations.AbstractInterpolation{var&quot;#s42&quot;, 2}), ITP_1D&lt;:(Interpolations.AbstractInterpolation{var&quot;#s42&quot;, 1})}, Vararg{T, 4}}} where T&lt;:AbstractFloat"><code>Muspel.Î±_cont</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Î±_cont(
    itp::ExtinctionItpNLTE{T},
    temperature::T,
    electron_density::T,
    h_neutral_density::T,
    proton_density::T,
)</code></pre><p>Calculates continuum extinction in m^-1 using interpolant structure.</p><p><strong>Arguments</strong></p><ul><li><code>itp</code>: Interpolant structure for a given wavelength, hydrogen NLTE case</li><li><code>temperature</code>: Temperature in K.</li><li><code>electron_density</code>: Electron number density in m^-3.</li><li><code>h_neutral_density</code>: Number density of neutral hydrogen in m^-3.</li><li><code>proton_density</code>: Proton number density in m^-3.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; npts = 100;
julia&gt; log_temp = LinRange(3.3, 5, npts);
julia&gt; log_ne = LinRange(15, 23, npts);
julia&gt; itp_nlte = create_Ïƒ_itp_NLTE(500., log_temp, log_ne,
                                  background_atoms, atom_interpolants);
julia&gt; Î±_cont(itp_nlte, 6000., 1e20, 1e20, 4.2462e15)
3.5998540603635895e-8</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tiagopereira/Muspel.jl/blob/407440565a4b0a3d62bbb9a899c2b292dbb41b7c/src/background.jl#L98-L126">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Muspel.Î±_cont_no_itp-Union{Tuple{T}, NTuple{5, T}} where T&lt;:AbstractFloat" href="#Muspel.Î±_cont_no_itp-Union{Tuple{T}, NTuple{5, T}} where T&lt;:AbstractFloat"><code>Muspel.Î±_cont_no_itp</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function Î±_cont_no_itp(
    Î»::T,
    temperature::T,
    electron_density::T,
    h_ground_density::T,
    h_neutral_density::T,
    proton_density::T
) where T &lt;: AbstractFloat</code></pre><p>Calculates continuum extinction without using an interpolation table. Does not include bound-free processes from background atoms.</p><p><strong>Arguments</strong></p><ul><li><code>Î»</code>: Wavelength in nm.</li><li><code>temperature</code>: Temperature in K.</li><li><code>electron_density</code>: Electron number density in m^-3.</li><li><code>h_ground_density</code>: Number density of hydrogen in the ground state, unit m^-3.</li><li><code>h_neutral_density</code>: Number density of neutral hydrogen, unit m^-3.</li><li><code>proton_density</code>: Proton number density in m^-3.</li></ul><p><strong>Returns</strong></p><ul><li><code>Î±</code>: Continuous extinction (Float) in m^-1.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tiagopereira/Muspel.jl/blob/407440565a4b0a3d62bbb9a899c2b292dbb41b7c/src/background.jl#L148-L171">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Muspel.ÏƒH_atoms_bf-Union{Tuple{T}, Tuple{Vector{Vector{Interpolations.FilledExtrapolation}}, AbstractVector{AtomicModel}, Real, T, T}} where T&lt;:AbstractFloat" href="#Muspel.ÏƒH_atoms_bf-Union{Tuple{T}, Tuple{Vector{Vector{Interpolations.FilledExtrapolation}}, AbstractVector{AtomicModel}, Real, T, T}} where T&lt;:AbstractFloat"><code>Muspel.ÏƒH_atoms_bf</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ÏƒH_atoms_bf(
    Ïƒ_atom_tables::Vector{Vector{Interpolations.FilledExtrapolation}},
    atoms::AbstractVector{AtomicModel},
    Î»::T,
    temperature::T,
    electron_density::T
) where T &lt;: AbstractFloat</code></pre><p>Compute the bound-free cross-sections per hydrogen atom from bf transitions in model atoms.</p><p><strong>Arguments</strong></p><ul><li><code>atom_interpolants</code>: Interpolation functions from get<em>atoms</em>bf_interpolant().</li><li><code>atoms</code>: A vector of AtomicModels with continua.</li><li><code>Î»</code>: Wavelength in nm.</li><li><code>temperature</code>: Temperature in K.</li><li><code>electron_density</code>: Number density in m^-3.</li></ul><p><strong>Returns</strong></p><ul><li><code>Ïƒ_Î»</code>: Total cross section per hydrogen atom. Corrected for stimulated emission.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tiagopereira/Muspel.jl/blob/407440565a4b0a3d62bbb9a899c2b292dbb41b7c/src/background.jl#L198-L218">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Muspel.ÏƒH_continuum-Union{Tuple{T}, Tuple{Real, T, T, Real}} where T&lt;:AbstractFloat" href="#Muspel.ÏƒH_continuum-Union{Tuple{T}, Tuple{Real, T, T, Real}} where T&lt;:AbstractFloat"><code>Muspel.ÏƒH_continuum</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ÏƒH_continuum(Î»::T, temperature::T, electron_density::T, ion_frac::T)</code></pre><p>Compute continuum cross sections in m^2 per hydrogen atom.</p><p><strong>Arguments</strong></p><ul><li><code>Î»</code>: wavelength in nm.</li><li><code>temperature</code>: temperature in K.</li><li><code>electron_density</code>: number density in m^-3.</li><li><code>ion_frac</code> : ionisation fraction.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tiagopereira/Muspel.jl/blob/407440565a4b0a3d62bbb9a899c2b292dbb41b7c/src/background.jl#L238-L248">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.19 on <span class="colophon-date" title="Monday 14 August 2023 07:58">Monday 14 August 2023</span>. Using Julia version 1.9.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
