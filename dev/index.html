<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · Muspel.jl</title><script data-outdated-warner src="assets/warner.js"></script><link rel="canonical" href="https://tiagopereira.github.io/Muspel.jl/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.044/juliamono.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>Muspel.jl</a></span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/tiagopereira/Muspel.jl/blob/main/docs/src/index.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Muspel"><a class="docs-heading-anchor" href="#Muspel">Muspel</a><a id="Muspel-1"></a><a class="docs-heading-anchor-permalink" href="#Muspel" title="Permalink"></a></h1><p>Documentation for <a href="https://github.com/tiagopereira/Muspel.jl">Muspel</a>.</p><ul><li><a href="#Muspel.Atmosphere1D"><code>Muspel.Atmosphere1D</code></a></li><li><a href="#Muspel.ExtinctionItpLTE"><code>Muspel.ExtinctionItpLTE</code></a></li><li><a href="#Muspel.ExtinctionItpNLTE"><code>Muspel.ExtinctionItpNLTE</code></a></li><li><a href="#Muspel.StokesA-NTuple{8, Any}"><code>Muspel.StokesA</code></a></li><li><a href="#Muspel._assign_unit-Tuple{Dict}"><code>Muspel._assign_unit</code></a></li><li><a href="#Muspel._read_broadening_single-Tuple{Dict, Vararg{Any, 5}}"><code>Muspel._read_broadening_single</code></a></li><li><a href="#Muspel._read_transition-Tuple{Dict, Any, Any}"><code>Muspel._read_transition</code></a></li><li><a href="#Muspel._spline_coeffs-Tuple{Any, Any}"><code>Muspel._spline_coeffs</code></a></li><li><a href="#Muspel._spline_stencil-Tuple{Any, Any, Any}"><code>Muspel._spline_stencil</code></a></li><li><a href="#Muspel._w2-Tuple{T} where T&lt;:AbstractFloat"><code>Muspel._w2</code></a></li><li><a href="#Muspel.blackbody_λ-Union{Tuple{T2}, Tuple{T1}, Tuple{T1, T2}} where {T1&lt;:Real, T2&lt;:AbstractFloat}"><code>Muspel.blackbody_λ</code></a></li><li><a href="#Muspel.calc_line_1D!-Union{Tuple{T}, Tuple{AtomicLine, RTBuffer{T}, Atmosphere1D{1, T, A, V} where {A&lt;:AbstractVector{T}, V&lt;:AbstractVector{T}}, AbstractVector{T}, AbstractVector{T}, ExtinctionItpNLTE{var&quot;#s37&quot;, T2, ITP_2D, ITP_1D} where {var&quot;#s37&quot;&lt;:Real, T2, ITP_2D&lt;:(Interpolations.AbstractInterpolation{var&quot;#s37&quot;, 2}), ITP_1D&lt;:(Interpolations.AbstractInterpolation{var&quot;#s37&quot;, 1})}, Interpolations.AbstractInterpolation{&lt;:Number, 2}}} where T&lt;:AbstractFloat"><code>Muspel.calc_line_1D!</code></a></li><li><a href="#Muspel.calc_λline_MULTI-Union{Tuple{T}, Tuple{Union{Unitful.Quantity{T, 𝐋, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐋, U}} where {L, S}} where U, Any, T, T, Union{Unitful.Quantity{T, 𝐋 𝐓^-1, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐋 𝐓^-1, U}} where {L, S}} where U}} where T&lt;:Real"><code>Muspel.calc_λline_MULTI</code></a></li><li><a href="#Muspel.calc_λline_RH-Union{Tuple{T}, Tuple{Union{Unitful.Quantity{T, 𝐋, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐋, U}} where {L, S}} where U, Any, T, T, Union{Unitful.Quantity{T, 𝐋 𝐓^-1, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐋 𝐓^-1, U}} where {L, S}} where U}} where T&lt;:Real"><code>Muspel.calc_λline_RH</code></a></li><li><a href="#Muspel.calc_τ_cont!-Union{Tuple{T}, Tuple{Atmosphere1D{1, T, A, V} where {A&lt;:AbstractVector{T}, V&lt;:AbstractVector{T}}, AbstractVector{&lt;:Real}, ExtinctionItpNLTE{var&quot;#s45&quot;, T2, ITP_2D, ITP_1D} where {var&quot;#s45&quot;&lt;:Real, T2, ITP_2D&lt;:(Interpolations.AbstractInterpolation{var&quot;#s45&quot;, 2}), ITP_1D&lt;:(Interpolations.AbstractInterpolation{var&quot;#s45&quot;, 1})}}} where T&lt;:AbstractFloat"><code>Muspel.calc_τ_cont!</code></a></li><li><a href="#Muspel.create_σ_itp_LTE-Union{Tuple{T}, Tuple{Real, AbstractRange{T}, AbstractRange{T}, AtomicModel, AbstractVector{AtomicModel}, Vector{Vector{Interpolations.FilledExtrapolation}}}} where T&lt;:Real"><code>Muspel.create_σ_itp_LTE</code></a></li><li><a href="#Muspel.create_σ_itp_NLTE-Union{Tuple{T}, Tuple{Real, AbstractRange{T}, AbstractRange{T}, AbstractVector{AtomicModel}, Vector{Vector{Interpolations.FilledExtrapolation}}}} where T&lt;:Real"><code>Muspel.create_σ_itp_NLTE</code></a></li><li><a href="#Muspel.damping-Union{Tuple{T}, Tuple{T, Real, Real}} where T&lt;:Real"><code>Muspel.damping</code></a></li><li><a href="#Muspel.doppler_width-Union{Tuple{T}, Tuple{Any, Any, T}} where T&lt;:AbstractFloat"><code>Muspel.doppler_width</code></a></li><li><a href="#Muspel.feautrier-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, AbstractVector{T}}} where T&lt;:AbstractFloat"><code>Muspel.feautrier</code></a></li><li><a href="#Muspel.g_JK-NTuple{6, Any}"><code>Muspel.g_JK</code></a></li><li><a href="#Muspel.g_LS-Tuple{Any, Any, Any}"><code>Muspel.g_LS</code></a></li><li><a href="#Muspel.g_eff-NTuple{4, Any}"><code>Muspel.g_eff</code></a></li><li><a href="#Muspel.g_jj-NTuple{5, Any}"><code>Muspel.g_jj</code></a></li><li><a href="#Muspel.get_atoms_bf_interpolant-Tuple{AbstractVector{AtomicModel}}"><code>Muspel.get_atoms_bf_interpolant</code></a></li><li><a href="#Muspel.get_zeeman_components-NTuple{6, Any}"><code>Muspel.get_zeeman_components</code></a></li><li><a href="#Muspel.get_σ_itp-Tuple{Muspel.AbstractAtmos, Real, Vector{String}}"><code>Muspel.get_σ_itp</code></a></li><li><a href="#Muspel.h_ionfrac_saha-Union{Tuple{T}, Tuple{T, Real}} where T&lt;:Real"><code>Muspel.h_ionfrac_saha</code></a></li><li><a href="#Muspel.incline_atmos-Tuple{Muspel.AbstractAtmos3D, Real, Real}"><code>Muspel.incline_atmos</code></a></li><li><a href="#Muspel.incline_data!-Tuple{AbstractArray{&lt;:Real, 3}, AbstractVector, Vararg{Real, 4}}"><code>Muspel.incline_data!</code></a></li><li><a href="#Muspel.incline_data_inv!-Tuple{AbstractArray{&lt;:Real, 3}, AbstractVector, Vararg{Real, 4}}"><code>Muspel.incline_data_inv!</code></a></li><li><a href="#Muspel.parse_label_LS-Tuple{Any}"><code>Muspel.parse_label_LS</code></a></li><li><a href="#Muspel.piecewise_1D_linear-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, AbstractVector{T}}} where T&lt;:AbstractFloat"><code>Muspel.piecewise_1D_linear</code></a></li><li><a href="#Muspel.piecewise_1D_linear!-Union{Tuple{T}, NTuple{4, AbstractVector{T}}} where T&lt;:AbstractFloat"><code>Muspel.piecewise_1D_linear!</code></a></li><li><a href="#Muspel.piecewise_1D_nn-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, AbstractVector{T}}} where T&lt;:AbstractFloat"><code>Muspel.piecewise_1D_nn</code></a></li><li><a href="#Muspel.project_vector!-Union{Tuple{A}, Tuple{A, A, A, Real, Real}} where A&lt;:(AbstractArray{&lt;:Real})"><code>Muspel.project_vector!</code></a></li><li><a href="#Muspel.read_atmos_hpops_multi3d-Tuple{Any, Any, Any}"><code>Muspel.read_atmos_hpops_multi3d</code></a></li><li><a href="#Muspel.read_atmos_hpops_rh-Tuple{Any, Any}"><code>Muspel.read_atmos_hpops_rh</code></a></li><li><a href="#Muspel.read_atmos_multi3d-Tuple{Any, Any}"><code>Muspel.read_atmos_multi3d</code></a></li><li><a href="#Muspel.read_atmos_rh-Tuple{Any}"><code>Muspel.read_atmos_rh</code></a></li><li><a href="#Muspel.read_atom-Tuple{Any}"><code>Muspel.read_atom</code></a></li><li><a href="#Muspel.read_continuum-Tuple{Dict, Any, Any, Any}"><code>Muspel.read_continuum</code></a></li><li><a href="#Muspel.read_line-Tuple{Dict, Vararg{Any, 6}}"><code>Muspel.read_line</code></a></li><li><a href="#Muspel.read_mesh-Tuple{Any}"><code>Muspel.read_mesh</code></a></li><li><a href="#Muspel.read_pops_multi3d-NTuple{5, Any}"><code>Muspel.read_pops_multi3d</code></a></li><li><a href="#Muspel.read_pops_rh-Tuple{Any, Any}"><code>Muspel.read_pops_rh</code></a></li><li><a href="#Muspel.saha_boltzmann-Union{Tuple{T}, Tuple{N}, Tuple{StaticArraysCore.SVector{N, &lt;:Real}, StaticArraysCore.SVector{N, &lt;:Real}, StaticArraysCore.SVector{N, &lt;:Real}, T, T, Real}} where {N, T&lt;:AbstractFloat}"><code>Muspel.saha_boltzmann</code></a></li><li><a href="#Muspel.saha_boltzmann!-Union{Tuple{T}, Tuple{N}, Tuple{StaticArraysCore.SVector{N, &lt;:Real}, StaticArraysCore.SVector{N, &lt;:Real}, StaticArraysCore.SVector{N, &lt;:Real}, Real, Real, Real, AbstractVector{T}}} where {N, T&lt;:AbstractFloat}"><code>Muspel.saha_boltzmann!</code></a></li><li><a href="#Muspel.stokes_profiles-Union{Tuple{T}, Tuple{AtomicLine, Interpolations.AbstractInterpolation{&lt;:Number, 2}, Vararg{T, 6}}} where T&lt;:AbstractFloat"><code>Muspel.stokes_profiles</code></a></li><li><a href="#Muspel.zeeman_strength-NTuple{4, Any}"><code>Muspel.zeeman_strength</code></a></li><li><a href="#Muspel.α_cont-Union{Tuple{T}, Tuple{ExtinctionItpNLTE{var&quot;#s48&quot;, T2, ITP_2D, ITP_1D} where {var&quot;#s48&quot;&lt;:Real, T2, ITP_2D&lt;:(Interpolations.AbstractInterpolation{var&quot;#s48&quot;, 2}), ITP_1D&lt;:(Interpolations.AbstractInterpolation{var&quot;#s48&quot;, 1})}, Vararg{T, 4}}} where T&lt;:AbstractFloat"><code>Muspel.α_cont</code></a></li><li><a href="#Muspel.α_cont-Union{Tuple{T}, Tuple{ExtinctionItpLTE{var&quot;#s48&quot;, T2, ITP_2D} where {var&quot;#s48&quot;&lt;:Real, T2, ITP_2D&lt;:(Interpolations.AbstractInterpolation{var&quot;#s48&quot;, 2})}, T, T, T}} where T&lt;:AbstractFloat"><code>Muspel.α_cont</code></a></li><li><a href="#Muspel.α_cont_no_itp-Union{Tuple{T}, NTuple{5, T}} where T&lt;:AbstractFloat"><code>Muspel.α_cont_no_itp</code></a></li><li><a href="#Muspel.γ_g-Tuple{Any, Any, Any}"><code>Muspel.γ_g</code></a></li><li><a href="#Muspel.σH_atoms_bf-Union{Tuple{T}, Tuple{Vector{Vector{Interpolations.FilledExtrapolation}}, AbstractVector{AtomicModel}, Real, T, T}} where T&lt;:AbstractFloat"><code>Muspel.σH_atoms_bf</code></a></li><li><a href="#Muspel.σH_continuum-Union{Tuple{T}, Tuple{Real, T, T, Real}} where T&lt;:AbstractFloat"><code>Muspel.σH_continuum</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="Muspel.Atmosphere1D" href="#Muspel.Atmosphere1D"><code>Muspel.Atmosphere1D</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Type for 1D atmospheres. Can contain both 1D only, or 1.5D atmospheres (multiple columns of 1D atmospheres).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tiagopereira/Muspel.jl/blob/98458a5c2e23c51cbfaa7d3c9845ef8af35efcb4/src/types.jl#L12-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Muspel.ExtinctionItpLTE" href="#Muspel.ExtinctionItpLTE"><code>Muspel.ExtinctionItpLTE</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Interpolant structure for continuum extinction, for use when hydrogen populations are computed in LTE (simplifies calculations).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tiagopereira/Muspel.jl/blob/98458a5c2e23c51cbfaa7d3c9845ef8af35efcb4/src/background.jl#L18-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Muspel.ExtinctionItpNLTE" href="#Muspel.ExtinctionItpNLTE"><code>Muspel.ExtinctionItpNLTE</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Interpolant structure for continuum extinction, for use when hydrogen populations are given explicitly (e.g. non-equilibrium ionisation or NLTE).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tiagopereira/Muspel.jl/blob/98458a5c2e23c51cbfaa7d3c9845ef8af35efcb4/src/background.jl#L33-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Muspel.StokesA-NTuple{8, Any}" href="#Muspel.StokesA-NTuple{8, Any}"><code>Muspel.StokesA</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Builds the reduced 4x4 Stokes propagation matrix, defined as:</p><pre><code class="nohighlight hljs">A = α_l / α_I ⎡0    ϕQ   ϕU   ϕV⎤
              ⎜ϕQ    0   ψV  -ψU⎥
              ⎜ϕU  -ψV    0   ψQ⎥
              ⎣ϕV   ψU  -ψQ    0⎦
</code></pre><p>where <code>α_I = α_cont + α_line * ϕI</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tiagopereira/Muspel.jl/blob/98458a5c2e23c51cbfaa7d3c9845ef8af35efcb4/src/zeeman.jl#L226-L237">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Muspel._assign_unit-Tuple{Dict}" href="#Muspel._assign_unit-Tuple{Dict}"><code>Muspel._assign_unit</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return a value with a unit given a dictionary read from a YAML file.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tiagopereira/Muspel.jl/blob/98458a5c2e23c51cbfaa7d3c9845ef8af35efcb4/src/read_utils.jl#L272-L274">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Muspel._read_broadening_single-Tuple{Dict, Vararg{Any, 5}}" href="#Muspel._read_broadening_single-Tuple{Dict, Vararg{Any, 5}}"><code>Muspel._read_broadening_single</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Reads individual broadening mechanisms and converts each to a multiplier constant and temperature exponent based on different recipes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tiagopereira/Muspel.jl/blob/98458a5c2e23c51cbfaa7d3c9845ef8af35efcb4/src/read_utils.jl#L353-L356">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Muspel._read_transition-Tuple{Dict, Any, Any}" href="#Muspel._read_transition-Tuple{Dict, Any, Any}"><code>Muspel._read_transition</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Helper function to parse transition upper and lower levels and compute wavelength. To be used with fields from the YAML atom format.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tiagopereira/Muspel.jl/blob/98458a5c2e23c51cbfaa7d3c9845ef8af35efcb4/src/read_utils.jl#L278-L281">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Muspel._spline_coeffs-Tuple{Any, Any}" href="#Muspel._spline_coeffs-Tuple{Any, Any}"><code>Muspel._spline_coeffs</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Computes coefficients for cubic spline interpolation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tiagopereira/Muspel.jl/blob/98458a5c2e23c51cbfaa7d3c9845ef8af35efcb4/src/incline.jl#L203-L205">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Muspel._spline_stencil-Tuple{Any, Any, Any}" href="#Muspel._spline_stencil-Tuple{Any, Any, Any}"><code>Muspel._spline_stencil</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Gets stencil coordinates for cubic spline.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tiagopereira/Muspel.jl/blob/98458a5c2e23c51cbfaa7d3c9845ef8af35efcb4/src/incline.jl#L226-L228">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Muspel._w2-Tuple{T} where T&lt;:AbstractFloat" href="#Muspel._w2-Tuple{T} where T&lt;:AbstractFloat"><code>Muspel._w2</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Computes weights for linear integration of source function, approximating <code>exp(-Δτ)</code> for very small and very large values of <code>Δτ</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tiagopereira/Muspel.jl/blob/98458a5c2e23c51cbfaa7d3c9845ef8af35efcb4/src/formal_solvers.jl#L234-L237">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Muspel.blackbody_λ-Union{Tuple{T2}, Tuple{T1}, Tuple{T1, T2}} where {T1&lt;:Real, T2&lt;:AbstractFloat}" href="#Muspel.blackbody_λ-Union{Tuple{T2}, Tuple{T1}, Tuple{T1, T2}} where {T1&lt;:Real, T2&lt;:AbstractFloat}"><code>Muspel.blackbody_λ</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Calculates the Blackbody (Planck) function per wavelength in nm and temperature in K. Outputs in kW m^-2 nm^-1.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tiagopereira/Muspel.jl/blob/98458a5c2e23c51cbfaa7d3c9845ef8af35efcb4/src/utils.jl#L5-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Muspel.calc_line_1D!-Union{Tuple{T}, Tuple{AtomicLine, RTBuffer{T}, Atmosphere1D{1, T, A, V} where {A&lt;:AbstractVector{T}, V&lt;:AbstractVector{T}}, AbstractVector{T}, AbstractVector{T}, ExtinctionItpNLTE{var&quot;#s37&quot;, T2, ITP_2D, ITP_1D} where {var&quot;#s37&quot;&lt;:Real, T2, ITP_2D&lt;:(Interpolations.AbstractInterpolation{var&quot;#s37&quot;, 2}), ITP_1D&lt;:(Interpolations.AbstractInterpolation{var&quot;#s37&quot;, 1})}, Interpolations.AbstractInterpolation{&lt;:Number, 2}}} where T&lt;:AbstractFloat" href="#Muspel.calc_line_1D!-Union{Tuple{T}, Tuple{AtomicLine, RTBuffer{T}, Atmosphere1D{1, T, A, V} where {A&lt;:AbstractVector{T}, V&lt;:AbstractVector{T}}, AbstractVector{T}, AbstractVector{T}, ExtinctionItpNLTE{var&quot;#s37&quot;, T2, ITP_2D, ITP_1D} where {var&quot;#s37&quot;&lt;:Real, T2, ITP_2D&lt;:(Interpolations.AbstractInterpolation{var&quot;#s37&quot;, 2}), ITP_1D&lt;:(Interpolations.AbstractInterpolation{var&quot;#s37&quot;, 1})}, Interpolations.AbstractInterpolation{&lt;:Number, 2}}} where T&lt;:AbstractFloat"><code>Muspel.calc_line_1D!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function calc_line_1D!(
    line::AtomicLine,
    buf::RTBuffer{T},
    atm::Atmosphere1D{T},
    n_up::AbstractVector{T},
    n_lo::AbstractVector{T},
    σ_itp::ExtinctionItpNLTE{&lt;:Real},
    voigt_itp::Interpolations.AbstractInterpolation{&lt;:Number, 2};
    to_end::Bool=false,
    initial_condition=:source
)</code></pre><p>Calculate emerging disk-centre intensity for a given line in a 1D atmosphere.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tiagopereira/Muspel.jl/blob/98458a5c2e23c51cbfaa7d3c9845ef8af35efcb4/src/intensity.jl#L4-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Muspel.calc_λline_MULTI-Union{Tuple{T}, Tuple{Union{Unitful.Quantity{T, 𝐋, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐋, U}} where {L, S}} where U, Any, T, T, Union{Unitful.Quantity{T, 𝐋 𝐓^-1, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐋 𝐓^-1, U}} where {L, S}} where U}} where T&lt;:Real" href="#Muspel.calc_λline_MULTI-Union{Tuple{T}, Tuple{Union{Unitful.Quantity{T, 𝐋, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐋, U}} where {L, S}} where U, Any, T, T, Union{Unitful.Quantity{T, 𝐋 𝐓^-1, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐋 𝐓^-1, U}} where {L, S}} where U}} where T&lt;:Real"><code>Muspel.calc_λline_MULTI</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Calculate line wavelengths using recipe from MULTI.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tiagopereira/Muspel.jl/blob/98458a5c2e23c51cbfaa7d3c9845ef8af35efcb4/src/read_utils.jl#L226-L228">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Muspel.calc_λline_RH-Union{Tuple{T}, Tuple{Union{Unitful.Quantity{T, 𝐋, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐋, U}} where {L, S}} where U, Any, T, T, Union{Unitful.Quantity{T, 𝐋 𝐓^-1, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐋 𝐓^-1, U}} where {L, S}} where U}} where T&lt;:Real" href="#Muspel.calc_λline_RH-Union{Tuple{T}, Tuple{Union{Unitful.Quantity{T, 𝐋, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐋, U}} where {L, S}} where U, Any, T, T, Union{Unitful.Quantity{T, 𝐋 𝐓^-1, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐋 𝐓^-1, U}} where {L, S}} where U}} where T&lt;:Real"><code>Muspel.calc_λline_RH</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Calculate line wavelengths using recipe from RH.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tiagopereira/Muspel.jl/blob/98458a5c2e23c51cbfaa7d3c9845ef8af35efcb4/src/read_utils.jl#L178-L180">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Muspel.calc_τ_cont!-Union{Tuple{T}, Tuple{Atmosphere1D{1, T, A, V} where {A&lt;:AbstractVector{T}, V&lt;:AbstractVector{T}}, AbstractVector{&lt;:Real}, ExtinctionItpNLTE{var&quot;#s45&quot;, T2, ITP_2D, ITP_1D} where {var&quot;#s45&quot;&lt;:Real, T2, ITP_2D&lt;:(Interpolations.AbstractInterpolation{var&quot;#s45&quot;, 2}), ITP_1D&lt;:(Interpolations.AbstractInterpolation{var&quot;#s45&quot;, 1})}}} where T&lt;:AbstractFloat" href="#Muspel.calc_τ_cont!-Union{Tuple{T}, Tuple{Atmosphere1D{1, T, A, V} where {A&lt;:AbstractVector{T}, V&lt;:AbstractVector{T}}, AbstractVector{&lt;:Real}, ExtinctionItpNLTE{var&quot;#s45&quot;, T2, ITP_2D, ITP_1D} where {var&quot;#s45&quot;&lt;:Real, T2, ITP_2D&lt;:(Interpolations.AbstractInterpolation{var&quot;#s45&quot;, 2}), ITP_1D&lt;:(Interpolations.AbstractInterpolation{var&quot;#s45&quot;, 1})}}} where T&lt;:AbstractFloat"><code>Muspel.calc_τ_cont!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Calculate continuum optical depth in the vertical direction, from the observer to the stellar interior. The wavelength is defined by σ_itp.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tiagopereira/Muspel.jl/blob/98458a5c2e23c51cbfaa7d3c9845ef8af35efcb4/src/intensity.jl#L82-L86">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Muspel.create_σ_itp_LTE-Union{Tuple{T}, Tuple{Real, AbstractRange{T}, AbstractRange{T}, AtomicModel, AbstractVector{AtomicModel}, Vector{Vector{Interpolations.FilledExtrapolation}}}} where T&lt;:Real" href="#Muspel.create_σ_itp_LTE-Union{Tuple{T}, Tuple{Real, AbstractRange{T}, AbstractRange{T}, AtomicModel, AbstractVector{AtomicModel}, Vector{Vector{Interpolations.FilledExtrapolation}}}} where T&lt;:Real"><code>Muspel.create_σ_itp_LTE</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">create_σ_itp_LTE(
    λ::T,
    log_temp::AbstractVector{T},
    log_ne::AbstractVector{T},
    H_atom::AtomicModel,
    background_atoms::AbstractVector{AtomicModel},
    atom_interpolants::Vector{Vector{Interpolations.FilledExtrapolation}},
)</code></pre><p>Create interpolant structure continuum cross section, for the case when hydrogen populations are not given explicitly (and are calculated using Saha). Includes cross sections from bound-free transition present in background atoms, plus the following sources of extinction:</p><pre><code class="nohighlight hljs">* sources from σH_continuum
* H ff</code></pre><p><strong>Arguments</strong></p><ul><li><code>λ</code>: wavelength in nm.</li><li><code>log_temp</code>: sequence of log10 temperature (K) for the table.</li><li><code>log_ne</code>: sequence of log10 electron density (m^-3) for the table.</li><li><code>H_atom</code>: a hydrogen model atom to compute Saha ionisation fractions</li><li><code>background_atoms</code> : sequence of model atoms</li><li><code>atom_interpolants</code> : sequence of bf interpolants corresponding to each background atom</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tiagopereira/Muspel.jl/blob/98458a5c2e23c51cbfaa7d3c9845ef8af35efcb4/src/background.jl#L386-L411">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Muspel.create_σ_itp_NLTE-Union{Tuple{T}, Tuple{Real, AbstractRange{T}, AbstractRange{T}, AbstractVector{AtomicModel}, Vector{Vector{Interpolations.FilledExtrapolation}}}} where T&lt;:Real" href="#Muspel.create_σ_itp_NLTE-Union{Tuple{T}, Tuple{Real, AbstractRange{T}, AbstractRange{T}, AbstractVector{AtomicModel}, Vector{Vector{Interpolations.FilledExtrapolation}}}} where T&lt;:Real"><code>Muspel.create_σ_itp_NLTE</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">create_σ_itp_NLTE(
    λ::Real,
    log_temp::AbstractVector{T},
    log_ne::AbstractVector{T},
    background_atoms::AbstractVector{AtomicModel},
    atom_interpolants::Vector{Vector{Interpolations.FilledExtrapolation}},
)</code></pre><p>Create interpolant structure continuum cross section, for the case of explicit hydrogen populations. Includes cross sections from bound-free transition present in background atoms, plus the following sources of extinction:</p><ul><li>Hminus bf and ff</li><li>H2+ molecule bf and ff</li><li>H ff</li></ul><p><strong>Arguments</strong></p><ul><li><code>λ</code>: wavelength in nm.</li><li><code>log_temp</code>: sequence of log10 temperature (K) for the table.</li><li><code>log_ne</code>: sequence of log10 electron density (m^-3) for the table.</li><li><code>background_atoms</code> : sequence of model atoms</li><li><code>atom_interpolants</code> : sequence of bf interpolants corresponding to each background atom</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tiagopereira/Muspel.jl/blob/98458a5c2e23c51cbfaa7d3c9845ef8af35efcb4/src/background.jl#L442-L465">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Muspel.damping-Union{Tuple{T}, Tuple{T, Real, Real}} where T&lt;:Real" href="#Muspel.damping-Union{Tuple{T}, Tuple{T, Real, Real}} where T&lt;:Real"><code>Muspel.damping</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Damping constant for γ in rad / s, λ and ΔλD in nm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tiagopereira/Muspel.jl/blob/98458a5c2e23c51cbfaa7d3c9845ef8af35efcb4/src/line.jl#L14-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Muspel.doppler_width-Union{Tuple{T}, Tuple{Any, Any, T}} where T&lt;:AbstractFloat" href="#Muspel.doppler_width-Union{Tuple{T}, Tuple{Any, Any, T}} where T&lt;:AbstractFloat"><code>Muspel.doppler_width</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Doppler width for mass in kg, temperature in K</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tiagopereira/Muspel.jl/blob/98458a5c2e23c51cbfaa7d3c9845ef8af35efcb4/src/line.jl#L6-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Muspel.feautrier-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, AbstractVector{T}}} where T&lt;:AbstractFloat" href="#Muspel.feautrier-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, AbstractVector{T}}} where T&lt;:AbstractFloat"><code>Muspel.feautrier</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function feautrier(
    z::Array{&lt;:Unitful.Length{T}, 1},
    α::Array{&lt;:PerLength{T}, 1},
    source_function::Array{&lt;:Unitful.Quantity, 1}
) where T &lt;: AbstractFloat</code></pre><p>Calculate solution to radiative transfer equation using the Feautrier method. Uses algorithm from <a href="https://ui.adsabs.harvard.edu/abs/1991A&amp;A...245..171R">Rybicki &amp; Hummer, 1991, A&amp;A 245</a>. Returns the height-dependent Feautrier variable <code>P</code>:</p><p class="math-container">\[P \equiv 1/2 (I^+ + I^-)\]</p><p>Currently operates under the following assumptions:</p><ul><li>The first index of the variables is the top of the atmosphere</li><li>The boundary conditions are zero radiation at the top and source function at the bottom</li></ul><p>Therefore, the emergent intensity is <code>2 * P[1]</code>, since <span>$I^-[1]=0$</span>.</p><p>Not properly tested, use with care!</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tiagopereira/Muspel.jl/blob/98458a5c2e23c51cbfaa7d3c9845ef8af35efcb4/src/formal_solvers.jl#L173-L195">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Muspel.g_JK-NTuple{6, Any}" href="#Muspel.g_JK-NTuple{6, Any}"><code>Muspel.g_JK</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Calculates Landé factor from JK coupling.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tiagopereira/Muspel.jl/blob/98458a5c2e23c51cbfaa7d3c9845ef8af35efcb4/src/zeeman.jl#L36-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Muspel.g_LS-Tuple{Any, Any, Any}" href="#Muspel.g_LS-Tuple{Any, Any, Any}"><code>Muspel.g_LS</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Calculates Landé factor from LS coupling.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tiagopereira/Muspel.jl/blob/98458a5c2e23c51cbfaa7d3c9845ef8af35efcb4/src/zeeman.jl#L24-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Muspel.g_eff-NTuple{4, Any}" href="#Muspel.g_eff-NTuple{4, Any}"><code>Muspel.g_eff</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Calculates the effective Landé factor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tiagopereira/Muspel.jl/blob/98458a5c2e23c51cbfaa7d3c9845ef8af35efcb4/src/zeeman.jl#L1-L3">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Muspel.g_jj-NTuple{5, Any}" href="#Muspel.g_jj-NTuple{5, Any}"><code>Muspel.g_jj</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Calculates Landé factor from jj coupling.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tiagopereira/Muspel.jl/blob/98458a5c2e23c51cbfaa7d3c9845ef8af35efcb4/src/zeeman.jl#L30-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Muspel.get_atoms_bf_interpolant-Tuple{AbstractVector{AtomicModel}}" href="#Muspel.get_atoms_bf_interpolant-Tuple{AbstractVector{AtomicModel}}"><code>Muspel.get_atoms_bf_interpolant</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_atoms_bf_interpolant(atoms::AbstractVector{AtomicModel})</code></pre><p>Returns interpolants for bound-free cross section data multiplied with abundances for each atom.</p><p><strong>Arguments</strong></p><ul><li><code>atoms</code>: A Vector of AtomicModels, with continua.</li></ul><p><strong>Returns</strong></p><ul><li><code>tables::Vector{Vector{Interpolations.FilledExtrapolation}}</code>:   Interpolation functions.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; ATOM_PATH = &quot;/my/atoms/dir/&quot;;
julia&gt; atoms = [
    &quot;Al.yaml&quot;,
    &quot;C.yaml&quot;,
    &quot;Ca.yaml&quot;,
    &quot;Fe.yaml&quot;,
    &quot;H_6.yaml&quot;,
    &quot;He.yaml&quot;,
    &quot;KI.yaml&quot;,
    &quot;Mg.yaml&quot;,
    &quot;N.yaml&quot;,
    &quot;Na.yaml&quot;,
    &quot;NiI.yaml&quot;,
    &quot;O.yaml&quot;,
    &quot;S.yaml&quot;,
    &quot;Si.yaml&quot;,
];
julia&gt; background_atoms = Vector{AtomicModel}(undef, length(atoms))
julia&gt; for (index, atom_file) in enumerate(atoms)
           background_atoms[index] = read_atom(join([ATOM_PATH, atom_file]))
       end
julia&gt; atom_interpolants = get_atoms_bf_interpolant(background_atoms);</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tiagopereira/Muspel.jl/blob/98458a5c2e23c51cbfaa7d3c9845ef8af35efcb4/src/background.jl#L329-L367">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Muspel.get_zeeman_components-NTuple{6, Any}" href="#Muspel.get_zeeman_components-NTuple{6, Any}"><code>Muspel.get_zeeman_components</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Computes Zeeman strengths and shifts for the π and σ components.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tiagopereira/Muspel.jl/blob/98458a5c2e23c51cbfaa7d3c9845ef8af35efcb4/src/zeeman.jl#L125-L127">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Muspel.get_σ_itp-Tuple{Muspel.AbstractAtmos, Real, Vector{String}}" href="#Muspel.get_σ_itp-Tuple{Muspel.AbstractAtmos, Real, Vector{String}}"><code>Muspel.get_σ_itp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_σ_itp(atmos::Atmosphere, λ::Real, atom_files::Vector{String}; npts=100)</code></pre><p>Construct monochromatic continuum cross section interpolant for a given atmosphere, and wavelength λ in nm. Includes all the processes included in <code>create_σ_itp_NLTE</code>, plus all the bound-free cross sections present in all model atom files in the list <code>atom_files</code>.</p><p>Here <code>atmos</code> is used only to get the minimum and maximum values of temperature and electron density, to build the interpolation table. The number of points in the table (both for log(temperature) and log(electron density)) is given by <code>npts</code> (default 100).</p><p><strong>Returns</strong></p><ul><li>ExtinctionItpNLTE: continuum cross section interpolant for explicit hydrogen populations. To be used in function <code>α_cont</code>.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; ATOM_PATH = AtomicData.get_atom_dir();
julia&gt; bckgr_atoms = [
    &quot;Al.yaml&quot;,
    &quot;C.yaml&quot;,
    &quot;Ca.yaml&quot;,
    &quot;Fe.yaml&quot;,
    &quot;H_6.yaml&quot;,
    &quot;He.yaml&quot;,
    &quot;KI.yaml&quot;,
    &quot;Mg.yaml&quot;,
    &quot;N.yaml&quot;,
    &quot;Na.yaml&quot;,
    &quot;NiI.yaml&quot;,
    &quot;O.yaml&quot;,
    &quot;S.yaml&quot;,
    &quot;Si.yaml&quot;,
];
julia&gt; atom_files = [joinpath(ATOM_PATH, a) for a in bckgr_atoms];
julia&gt; atmos = atmos = read_atmos_rh(MY_ATMOS);
julia&gt; itp = get_σ_itp(atmos, 500.0, atom_files)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tiagopereira/Muspel.jl/blob/98458a5c2e23c51cbfaa7d3c9845ef8af35efcb4/src/background.jl#L272-L312">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Muspel.h_ionfrac_saha-Union{Tuple{T}, Tuple{T, Real}} where T&lt;:Real" href="#Muspel.h_ionfrac_saha-Union{Tuple{T}, Tuple{T, Real}} where T&lt;:Real"><code>Muspel.h_ionfrac_saha</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">h_ionfrac_saha(temp::T, electron_density::T)::T where {T &lt;: Real}</code></pre><p>Calculate ionisation fraction of hydrogen using Saha.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tiagopereira/Muspel.jl/blob/98458a5c2e23c51cbfaa7d3c9845ef8af35efcb4/src/lte.jl#L149-L153">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Muspel.incline_atmos-Tuple{Muspel.AbstractAtmos3D, Real, Real}" href="#Muspel.incline_atmos-Tuple{Muspel.AbstractAtmos3D, Real, Real}"><code>Muspel.incline_atmos</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">incline_atmos(atmos_in::AbstractAtmos3D, μ::Real, φ::Real)</code></pre><p>Transforms a 3D atmosphere into an inclined coordinate system, given by a rotation by a polar angle θ, given by μ = cos(θ) and an azimuthal angle φ. The output is an atmosphere of the same type, where the quantities have been interpolated to the same number of depth points and the vector quantities projected onto the new axes.</p><p>Assumes the following:</p><ol><li>Order of the axes in 3D arrays is (z, y, x)</li><li>Horizontally periodic boundary conditions</li><li>The first index in the height direction is fixed in the polar rotation</li><li>A right handed system, so that:</li></ol><pre><code class="nohighlight hljs">      z ↑.            - θ is the clockwise polar rotation from the z axis
        |  .          - φ is the clockwise azimuthal rotation from the x axis
        |    .
        |      .
        |        *
        |      . .
        | θ  .   .
        |  .     .
        |.       .
        +--------.-----→ y
       /  .      .   /
      /  φ  .    .
     /         . . /
    /- - - - - - .
  x</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tiagopereira/Muspel.jl/blob/98458a5c2e23c51cbfaa7d3c9845ef8af35efcb4/src/incline.jl#L5-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Muspel.incline_data!-Tuple{AbstractArray{&lt;:Real, 3}, AbstractVector, Vararg{Real, 4}}" href="#Muspel.incline_data!-Tuple{AbstractArray{&lt;:Real, 3}, AbstractVector, Vararg{Real, 4}}"><code>Muspel.incline_data!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">incline_data!(
        data::AbstractArray{&lt;: Real, 3},
        z::AbstractVector,
        dx::Real,
        dy::Real,
        μ::Real,
        ϕ::Real
)</code></pre><p>Transforms a 3D array into an inclined coordinate system, according to a polar angle given by μ = cos(θ), and an azimuthal angle ϕ. Uses cubic spline interpolation, and updates <code>data</code> in-place.</p><p>This version only works if height is the first dimension in <code>data</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tiagopereira/Muspel.jl/blob/98458a5c2e23c51cbfaa7d3c9845ef8af35efcb4/src/incline.jl#L174-L189">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Muspel.incline_data_inv!-Tuple{AbstractArray{&lt;:Real, 3}, AbstractVector, Vararg{Real, 4}}" href="#Muspel.incline_data_inv!-Tuple{AbstractArray{&lt;:Real, 3}, AbstractVector, Vararg{Real, 4}}"><code>Muspel.incline_data_inv!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">incline_data_inv!(
        data::AbstractArray{&lt;: Real, 3},
        z::AbstractVector,
        dx::Real,
        dy::Real,
        μ::Real,
        ϕ::Real
)</code></pre><p>Transforms a 3D array into an inclined coordinate system, according to a polar angle given by μ = cos(θ), and an azimuthal angle ϕ. Uses cubic spline interpolation, and updates <code>data</code> in-place. Based on trnslt.f90 from Åke Nordlund.</p><p>This version only works if height is the last dimension in <code>data</code>. This is 3-5x faster than <code>incline_data!</code> because the loop order is optimised for this memory configuration.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tiagopereira/Muspel.jl/blob/98458a5c2e23c51cbfaa7d3c9845ef8af35efcb4/src/incline.jl#L104-L122">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Muspel.parse_label_LS-Tuple{Any}" href="#Muspel.parse_label_LS-Tuple{Any}"><code>Muspel.parse_label_LS</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Parses an atomic level label in RH format, to extract the atomic numbers S and L.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tiagopereira/Muspel.jl/blob/98458a5c2e23c51cbfaa7d3c9845ef8af35efcb4/src/zeeman.jl#L87-L89">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Muspel.piecewise_1D_linear!-Union{Tuple{T}, NTuple{4, AbstractVector{T}}} where T&lt;:AbstractFloat" href="#Muspel.piecewise_1D_linear!-Union{Tuple{T}, NTuple{4, AbstractVector{T}}} where T&lt;:AbstractFloat"><code>Muspel.piecewise_1D_linear!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">piecewise_1D_linear!(
    z::AbstractVector{T},
    α::AbstractVector{T},
    source_function::AbstractVector{T},
    intensity::AbstractVector{T};
    to_end::Bool=false,
    initial_condition=:source
) where T &lt;: AbstractFloat</code></pre><p>Compute piecewise integration of the radiative transfer equation, assuming linear integration of the source function, for a given height <code>z</code>, extinction <code>α</code> and <code>source_function</code> and <code>intensity</code> (existing array where the output will be saved into). The optional keyword argument <code>to_end</code> defines the direction of the integration: if <code>false</code> (default) will start to integrate intensity from the last element to the first, and if <code>true</code> will integrate from the first element to the last. <code>initial_condition</code> can take two values: <code>:zero</code> for no radiation, or <code>:source</code> (default) to take the source function at the starting point.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tiagopereira/Muspel.jl/blob/98458a5c2e23c51cbfaa7d3c9845ef8af35efcb4/src/formal_solvers.jl#L115-L135">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Muspel.piecewise_1D_linear-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, AbstractVector{T}}} where T&lt;:AbstractFloat" href="#Muspel.piecewise_1D_linear-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, AbstractVector{T}}} where T&lt;:AbstractFloat"><code>Muspel.piecewise_1D_linear</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">piecewise_1D_linear(
    z::AbstractVector{T},
    α::AbstractVector{T},
    source_function::AbstractVector{T};
    to_end::Bool=false,
    initial_condition=:source
) where T &lt;: AbstractFloat</code></pre><p>DEPRECATED, use piecewise<em>1D</em>linear! Compute piecewise integration of the radiative transfer equation, assuming linear integration of the source function, for a given height <code>z</code>, extinction <code>α</code> and <code>source_function</code>. The optional keyword argument <code>to_end</code> defines the direction of the integration: if <code>false</code> (default) will start to integrate intensity from the last element to the first, and if <code>true</code> will integrate from the first element to the last. <code>initial_condition</code> can take two values: <code>:zero</code> for no radiation, or <code>:source</code> (default) to take the source function at the starting point.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tiagopereira/Muspel.jl/blob/98458a5c2e23c51cbfaa7d3c9845ef8af35efcb4/src/formal_solvers.jl#L60-L79">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Muspel.piecewise_1D_nn-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, AbstractVector{T}}} where T&lt;:AbstractFloat" href="#Muspel.piecewise_1D_nn-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, AbstractVector{T}}} where T&lt;:AbstractFloat"><code>Muspel.piecewise_1D_nn</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">piecewise_1D_nn(
    z::AbstractVector{T},
    α::AbstractVector{T},
    source_function::AbstractVector{T};
    to_end::Bool=false,
    initial_condition=:source
) where T &lt;: AbstractFloat</code></pre><p>Compute piecewise integration of the radiative transfer equation, assuming nearest-neighbour integration of the source function, for a given height <code>z</code>, extinction <code>α</code> and <code>source_function</code>. The optional keyword argument <code>to_end</code> defines the direction of the integration: if <code>false</code> (default) will start to integrate intensity from the last element to the first, and if <code>true</code> will integrate from the first element to the last. <code>initial_condition</code> can take two values: <code>:zero</code> for no radiation, or <code>:source</code> (default) to take the source function at the starting point.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tiagopereira/Muspel.jl/blob/98458a5c2e23c51cbfaa7d3c9845ef8af35efcb4/src/formal_solvers.jl#L6-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Muspel.project_vector!-Union{Tuple{A}, Tuple{A, A, A, Real, Real}} where A&lt;:(AbstractArray{&lt;:Real})" href="#Muspel.project_vector!-Union{Tuple{A}, Tuple{A, A, A, Real, Real}} where A&lt;:(AbstractArray{&lt;:Real})"><code>Muspel.project_vector!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">project_vector!(vx::A, vy::A, vz::A, μ::Real, φ::Real)</code></pre><p>Projects a vector in 3D space according to the rotation by an polar angle θ, given by μ = cos(θ) and an azimuthal angle φ. The inputs are the vector components in the x, y, and z axes, for an array of a given size (typically 3D).</p><p>Assumes the following:</p><ol><li>θ is the clockwise polar rotation from the z axis</li><li>φ is the clockwise azimuthal rotation from the x axis</li><li>The rotation of the vector is the same as the rotation from the axes (x, y, z) into a new system (x&#39;, y&#39;, z&#39;) given by the rotation matrix:</li></ol><pre><code class="nohighlight hljs">               Polar          Azimuthal
   ⎡x&#39;⎤ = ⎡cosθ  0  -sinθ⎤⎡ cosφ  sinφ  0⎤⎡x⎤
   ⎜y&#39;⎥   ⎜  0   1    0  ⎥⎜-sinφ  cosφ  0⎥⎜y⎥
   ⎣z&#39;⎦   ⎣sinθ  0   cosθ⎦⎣   0     0   1⎦⎣z⎦

   ⌈x&#39;⎤ = ⎡cosθcosφ  cosθsinφ  -sinφ⎤⎡x⎤
   |y&#39;⎥   ⎜ -sinφ      cosφ       0 ⎥⎜y⎥
   ⌊z&#39;⎦   ⎣sinθcosφ  sinθsinφ   cosθ⎦⎣z⎦</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tiagopereira/Muspel.jl/blob/98458a5c2e23c51cbfaa7d3c9845ef8af35efcb4/src/incline.jl#L61-L86">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Muspel.read_atmos_hpops_multi3d-Tuple{Any, Any, Any}" href="#Muspel.read_atmos_hpops_multi3d-Tuple{Any, Any, Any}"><code>Muspel.read_atmos_hpops_multi3d</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Reads atmosphere in the input format of MULTI3D, at the same time as the hydrogen populations. Only works for a H NLTE run. Only Float32 files are supported at the moment.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tiagopereira/Muspel.jl/blob/98458a5c2e23c51cbfaa7d3c9845ef8af35efcb4/src/read_atmos.jl#L168-L172">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Muspel.read_atmos_hpops_rh-Tuple{Any, Any}" href="#Muspel.read_atmos_hpops_rh-Tuple{Any, Any}"><code>Muspel.read_atmos_hpops_rh</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Reads RH atmosphere. Returns always in single precision.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tiagopereira/Muspel.jl/blob/98458a5c2e23c51cbfaa7d3c9845ef8af35efcb4/src/read_atmos.jl#L57-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Muspel.read_atmos_multi3d-Tuple{Any, Any}" href="#Muspel.read_atmos_multi3d-Tuple{Any, Any}"><code>Muspel.read_atmos_multi3d</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Reads atmosphere in the input format of MULTI3D. Only Float32 atmospheres are supported at the moment.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tiagopereira/Muspel.jl/blob/98458a5c2e23c51cbfaa7d3c9845ef8af35efcb4/src/read_atmos.jl#L107-L110">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Muspel.read_atmos_rh-Tuple{Any}" href="#Muspel.read_atmos_rh-Tuple{Any}"><code>Muspel.read_atmos_rh</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Reads RH atmosphere. Returns always in single precision.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tiagopereira/Muspel.jl/blob/98458a5c2e23c51cbfaa7d3c9845ef8af35efcb4/src/read_atmos.jl#L11-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Muspel.read_atom-Tuple{Any}" href="#Muspel.read_atom-Tuple{Any}"><code>Muspel.read_atom</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Reads atom in YAML format, returns AtomicModel structure</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tiagopereira/Muspel.jl/blob/98458a5c2e23c51cbfaa7d3c9845ef8af35efcb4/src/read_utils.jl#L6-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Muspel.read_continuum-Tuple{Dict, Any, Any, Any}" href="#Muspel.read_continuum-Tuple{Dict, Any, Any, Any}"><code>Muspel.read_continuum</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Reads continuum transition data in a Dict read from a YAML-formatted atom file. Needs level energies χ, ionisation stages, and level ids from atom file.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tiagopereira/Muspel.jl/blob/98458a5c2e23c51cbfaa7d3c9845ef8af35efcb4/src/read_utils.jl#L53-L56">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Muspel.read_line-Tuple{Dict, Vararg{Any, 6}}" href="#Muspel.read_line-Tuple{Dict, Vararg{Any, 6}}"><code>Muspel.read_line</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Reads spectral line data in a Dict read from a YAML-formatted atom file. Needs level energies χ, ionisation stages, labels, level ids and atomic mass from atom file.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tiagopereira/Muspel.jl/blob/98458a5c2e23c51cbfaa7d3c9845ef8af35efcb4/src/read_utils.jl#L86-L90">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Muspel.read_mesh-Tuple{Any}" href="#Muspel.read_mesh-Tuple{Any}"><code>Muspel.read_mesh</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Reads mesh file from Bifrost or MULTI3D.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tiagopereira/Muspel.jl/blob/98458a5c2e23c51cbfaa7d3c9845ef8af35efcb4/src/read_atmos.jl#L249-L251">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Muspel.read_pops_multi3d-NTuple{5, Any}" href="#Muspel.read_pops_multi3d-NTuple{5, Any}"><code>Muspel.read_pops_multi3d</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Reads NLTE populations from MULTI3D output. Does NOT permute dims. Only Float32 files are supported at the moment.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tiagopereira/Muspel.jl/blob/98458a5c2e23c51cbfaa7d3c9845ef8af35efcb4/src/read_atmos.jl#L234-L237">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Muspel.read_pops_rh-Tuple{Any, Any}" href="#Muspel.read_pops_rh-Tuple{Any, Any}"><code>Muspel.read_pops_rh</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Reads array with populations for a given species.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tiagopereira/Muspel.jl/blob/98458a5c2e23c51cbfaa7d3c9845ef8af35efcb4/src/read_atmos.jl#L89-L91">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Muspel.saha_boltzmann!-Union{Tuple{T}, Tuple{N}, Tuple{StaticArraysCore.SVector{N, &lt;:Real}, StaticArraysCore.SVector{N, &lt;:Real}, StaticArraysCore.SVector{N, &lt;:Real}, Real, Real, Real, AbstractVector{T}}} where {N, T&lt;:AbstractFloat}" href="#Muspel.saha_boltzmann!-Union{Tuple{T}, Tuple{N}, Tuple{StaticArraysCore.SVector{N, &lt;:Real}, StaticArraysCore.SVector{N, &lt;:Real}, StaticArraysCore.SVector{N, &lt;:Real}, Real, Real, Real, AbstractVector{T}}} where {N, T&lt;:AbstractFloat}"><code>Muspel.saha_boltzmann!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function saha_boltzmann!(
    χ::SVector,
    g::SVector,
    stage::SVector,
    temperature::T,
    electron_density::T,
    atom_density::T,
    populations::AbstractArray{T, 1},
) where T &lt;: AbstractFloat

function saha_boltzmann!(
    atom::AtomicModel,
    temperature::T,
    electron_density::T,
    atom_density::T,
    populations::AbstractArray{T, 1},
) where T &lt;: AbstractFloat</code></pre><p>Inplace version of <code>saha_boltzmann</code><code>. Calculates atomic level populations according to the Saha-Boltzmann distribution, placing them in an existing</code>populations` array.</p><p><strong>Arguments</strong></p><ul><li><code>χ</code>: level energies in J</li><li><code>g</code>: statistical weights of levels</li><li><code>stage</code>: ionisation stage of each level (starting at 1 for neutral)</li><li>Or, instead of the three above, an instance of <code>AtomicModel</code></li><li><code>temperature</code>: temperature in Kelvin</li><li><code>electron_density</code>: electron density in m^-3</li><li><code>atom_density</code>: total number density (in all levels) of target species</li><li><code>populations</code>: 1D array for output, must be same length as number of levels</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tiagopereira/Muspel.jl/blob/98458a5c2e23c51cbfaa7d3c9845ef8af35efcb4/src/lte.jl#L65-L97">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Muspel.saha_boltzmann-Union{Tuple{T}, Tuple{N}, Tuple{StaticArraysCore.SVector{N, &lt;:Real}, StaticArraysCore.SVector{N, &lt;:Real}, StaticArraysCore.SVector{N, &lt;:Real}, T, T, Real}} where {N, T&lt;:AbstractFloat}" href="#Muspel.saha_boltzmann-Union{Tuple{T}, Tuple{N}, Tuple{StaticArraysCore.SVector{N, &lt;:Real}, StaticArraysCore.SVector{N, &lt;:Real}, StaticArraysCore.SVector{N, &lt;:Real}, T, T, Real}} where {N, T&lt;:AbstractFloat}"><code>Muspel.saha_boltzmann</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function saha_boltzmann(
    χ::SVector,
    g::SVector,
    stage::SVector,
    temperature::T,
    electron_density::T,
    atom_density::T
) where T &lt;: AbstractFloat

function saha_boltzmann(
    atom::AtomicModel,
    temperature::T,
    electron_density::T,
    atom_density::T,
) where T &lt;: AbstractFloat</code></pre><p>Calculates atomic level populations according to the Saha-Boltzmann distribution.</p><p><strong>Arguments</strong></p><ul><li><code>χ</code>: level energies in J</li><li><code>g</code>: statistical weights of levels</li><li><code>stage</code>: ionisation stage of each level (starting at 1 for neutral)</li><li>Or, instead of the three above, an instance of <code>AtomicModel</code></li><li><code>temperature</code>: temperature in Kelvin</li><li><code>electron_density</code>: electron density in m^-3</li><li><code>atom_density</code>: total number density (in all levels) of target species</li></ul><p><strong>Returns</strong></p><ul><li><code>populations</code>: MVector{nlevels} with relative level populations in m^-3</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tiagopereira/Muspel.jl/blob/98458a5c2e23c51cbfaa7d3c9845ef8af35efcb4/src/lte.jl#L10-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Muspel.stokes_profiles-Union{Tuple{T}, Tuple{AtomicLine, Interpolations.AbstractInterpolation{&lt;:Number, 2}, Vararg{T, 6}}} where T&lt;:AbstractFloat" href="#Muspel.stokes_profiles-Union{Tuple{T}, Tuple{AtomicLine, Interpolations.AbstractInterpolation{&lt;:Number, 2}, Vararg{T, 6}}} where T&lt;:AbstractFloat"><code>Muspel.stokes_profiles</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Computes line profiles under Zeeman effect, for all Stokes parameters and also including magneto-optical effects.</p><p>Returns a 7-element tuple with: (ϕI, ϕQ, ϕU, ϕV, ψQ, ψU, ψV).</p><p>Takes into account the symmetry of H and anti-symmetry of L, so voigt_itp only needs to cover positive values of v.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tiagopereira/Muspel.jl/blob/98458a5c2e23c51cbfaa7d3c9845ef8af35efcb4/src/zeeman.jl#L172-L180">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Muspel.zeeman_strength-NTuple{4, Any}" href="#Muspel.zeeman_strength-NTuple{4, Any}"><code>Muspel.zeeman_strength</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Calculates strengths of Zeeman components. These strengths are normalised.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tiagopereira/Muspel.jl/blob/98458a5c2e23c51cbfaa7d3c9845ef8af35efcb4/src/zeeman.jl#L42-L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Muspel.α_cont-Union{Tuple{T}, Tuple{ExtinctionItpLTE{var&quot;#s48&quot;, T2, ITP_2D} where {var&quot;#s48&quot;&lt;:Real, T2, ITP_2D&lt;:(Interpolations.AbstractInterpolation{var&quot;#s48&quot;, 2})}, T, T, T}} where T&lt;:AbstractFloat" href="#Muspel.α_cont-Union{Tuple{T}, Tuple{ExtinctionItpLTE{var&quot;#s48&quot;, T2, ITP_2D} where {var&quot;#s48&quot;&lt;:Real, T2, ITP_2D&lt;:(Interpolations.AbstractInterpolation{var&quot;#s48&quot;, 2})}, T, T, T}} where T&lt;:AbstractFloat"><code>Muspel.α_cont</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">α_cont(
    itp::ExtinctionItpLTE{T},
    temperature::T,
    electron_density::T,
    hydrogen_density::T,
)</code></pre><p>Calculates continuum extinction in m^-1 using interpolant structure.</p><p><strong>Arguments</strong></p><ul><li><code>itp</code>: Interpolant structure for a given wavelength, hydrogen LTE case</li><li><code>temperature</code>: Temperature in K.</li><li><code>electron_density</code>: Electron number density in m^-3.</li><li><code>hydrogen_density</code>: Number density of hydrogen atoms (all stages), unit m^-3.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; npts = 100;
julia&gt; log_temp = LinRange(3.3, 5, npts);
julia&gt; log_ne = LinRange(15, 23, npts);
julia&gt; H_3 = read_atom(&quot;H_3.yaml&quot;);
julia&gt; itp_lte = create_σ_itp_LTE(500., log_temp, log_ne, H_3,
                                  background_atoms, atom_interpolants);
julia&gt; α_cont(itp_lte, 6000., 1e20, 1e20)
3.59972810095902e-8</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tiagopereira/Muspel.jl/blob/98458a5c2e23c51cbfaa7d3c9845ef8af35efcb4/src/background.jl#L55-L82">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Muspel.α_cont-Union{Tuple{T}, Tuple{ExtinctionItpNLTE{var&quot;#s48&quot;, T2, ITP_2D, ITP_1D} where {var&quot;#s48&quot;&lt;:Real, T2, ITP_2D&lt;:(Interpolations.AbstractInterpolation{var&quot;#s48&quot;, 2}), ITP_1D&lt;:(Interpolations.AbstractInterpolation{var&quot;#s48&quot;, 1})}, Vararg{T, 4}}} where T&lt;:AbstractFloat" href="#Muspel.α_cont-Union{Tuple{T}, Tuple{ExtinctionItpNLTE{var&quot;#s48&quot;, T2, ITP_2D, ITP_1D} where {var&quot;#s48&quot;&lt;:Real, T2, ITP_2D&lt;:(Interpolations.AbstractInterpolation{var&quot;#s48&quot;, 2}), ITP_1D&lt;:(Interpolations.AbstractInterpolation{var&quot;#s48&quot;, 1})}, Vararg{T, 4}}} where T&lt;:AbstractFloat"><code>Muspel.α_cont</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">α_cont(
    itp::ExtinctionItpNLTE{T},
    temperature::T,
    electron_density::T,
    h_neutral_density::T,
    proton_density::T,
)</code></pre><p>Calculates continuum extinction in m^-1 using interpolant structure.</p><p><strong>Arguments</strong></p><ul><li><code>itp</code>: Interpolant structure for a given wavelength, hydrogen NLTE case</li><li><code>temperature</code>: Temperature in K.</li><li><code>electron_density</code>: Electron number density in m^-3.</li><li><code>h_neutral_density</code>: Number density of neutral hydrogen in m^-3.</li><li><code>proton_density</code>: Proton number density in m^-3.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; npts = 100;
julia&gt; log_temp = LinRange(3.3, 5, npts);
julia&gt; log_ne = LinRange(15, 23, npts);
julia&gt; itp_nlte = create_σ_itp_NLTE(500., log_temp, log_ne,
                                  background_atoms, atom_interpolants);
julia&gt; α_cont(itp_nlte, 6000., 1e20, 1e20, 4.2462e15)
3.5998540603635895e-8</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tiagopereira/Muspel.jl/blob/98458a5c2e23c51cbfaa7d3c9845ef8af35efcb4/src/background.jl#L98-L126">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Muspel.α_cont_no_itp-Union{Tuple{T}, NTuple{5, T}} where T&lt;:AbstractFloat" href="#Muspel.α_cont_no_itp-Union{Tuple{T}, NTuple{5, T}} where T&lt;:AbstractFloat"><code>Muspel.α_cont_no_itp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function α_cont_no_itp(
    λ::T,
    temperature::T,
    electron_density::T,
    h_ground_density::T,
    h_neutral_density::T,
    proton_density::T
) where T &lt;: AbstractFloat</code></pre><p>Calculates continuum extinction without using an interpolation table. Does not include bound-free processes from background atoms.</p><p><strong>Arguments</strong></p><ul><li><code>λ</code>: Wavelength in nm.</li><li><code>temperature</code>: Temperature in K.</li><li><code>electron_density</code>: Electron number density in m^-3.</li><li><code>h_ground_density</code>: Number density of hydrogen in the ground state, unit m^-3.</li><li><code>h_neutral_density</code>: Number density of neutral hydrogen, unit m^-3.</li><li><code>proton_density</code>: Proton number density in m^-3.</li></ul><p><strong>Returns</strong></p><ul><li><code>α</code>: Continuous extinction (Float) in m^-1.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tiagopereira/Muspel.jl/blob/98458a5c2e23c51cbfaa7d3c9845ef8af35efcb4/src/background.jl#L148-L171">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Muspel.γ_g-Tuple{Any, Any, Any}" href="#Muspel.γ_g-Tuple{Any, Any, Any}"><code>Muspel.γ_g</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Utility function to compute Landé factors from various types of coupling. From pp. 76-77 of <a href="https://ui.adsabs.harvard.edu/abs/2004ASSL..307.....L/abstract">Landi Degl&#39;Innocenti &amp; Landolfi (2004)</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tiagopereira/Muspel.jl/blob/98458a5c2e23c51cbfaa7d3c9845ef8af35efcb4/src/zeeman.jl#L10-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Muspel.σH_atoms_bf-Union{Tuple{T}, Tuple{Vector{Vector{Interpolations.FilledExtrapolation}}, AbstractVector{AtomicModel}, Real, T, T}} where T&lt;:AbstractFloat" href="#Muspel.σH_atoms_bf-Union{Tuple{T}, Tuple{Vector{Vector{Interpolations.FilledExtrapolation}}, AbstractVector{AtomicModel}, Real, T, T}} where T&lt;:AbstractFloat"><code>Muspel.σH_atoms_bf</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">σH_atoms_bf(
    σ_atom_tables::Vector{Vector{Interpolations.FilledExtrapolation}},
    atoms::AbstractVector{AtomicModel},
    λ::T,
    temperature::T,
    electron_density::T
) where T &lt;: AbstractFloat</code></pre><p>Compute the bound-free cross-sections per hydrogen atom from bf transitions in model atoms.</p><p><strong>Arguments</strong></p><ul><li><code>atom_interpolants</code>: Interpolation functions from get<em>atoms</em>bf_interpolant().</li><li><code>atoms</code>: A vector of AtomicModels with continua.</li><li><code>λ</code>: Wavelength in nm.</li><li><code>temperature</code>: Temperature in K.</li><li><code>electron_density</code>: Number density in m^-3.</li></ul><p><strong>Returns</strong></p><ul><li><code>σ_λ</code>: Total cross section per hydrogen atom. Corrected for stimulated emission.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tiagopereira/Muspel.jl/blob/98458a5c2e23c51cbfaa7d3c9845ef8af35efcb4/src/background.jl#L198-L218">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Muspel.σH_continuum-Union{Tuple{T}, Tuple{Real, T, T, Real}} where T&lt;:AbstractFloat" href="#Muspel.σH_continuum-Union{Tuple{T}, Tuple{Real, T, T, Real}} where T&lt;:AbstractFloat"><code>Muspel.σH_continuum</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">σH_continuum(λ::T, temperature::T, electron_density::T, ion_frac::T)</code></pre><p>Compute continuum cross sections in m^2 per hydrogen atom.</p><p><strong>Arguments</strong></p><ul><li><code>λ</code>: wavelength in nm.</li><li><code>temperature</code>: temperature in K.</li><li><code>electron_density</code>: number density in m^-3.</li><li><code>ion_frac</code> : ionisation fraction.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tiagopereira/Muspel.jl/blob/98458a5c2e23c51cbfaa7d3c9845ef8af35efcb4/src/background.jl#L238-L248">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.19 on <span class="colophon-date" title="Thursday 20 June 2024 19:59">Thursday 20 June 2024</span>. Using Julia version 1.10.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
