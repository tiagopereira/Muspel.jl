var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = Muspel","category":"page"},{"location":"#Muspel","page":"Home","title":"Muspel","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for Muspel.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [Muspel]","category":"page"},{"location":"#Muspel.Atmosphere1D","page":"Home","title":"Muspel.Atmosphere1D","text":"Type for 1D atmospheres. Can contain both 1D only, or 1.5D atmospheres (multiple columns of 1D atmospheres).\n\n\n\n\n\n","category":"type"},{"location":"#Muspel.ExtinctionItpLTE","page":"Home","title":"Muspel.ExtinctionItpLTE","text":"Interpolant structure for continuum extinction, for use when hydrogen populations are computed in LTE (simplifies calculations).\n\n\n\n\n\n","category":"type"},{"location":"#Muspel.ExtinctionItpNLTE","page":"Home","title":"Muspel.ExtinctionItpNLTE","text":"Interpolant structure for continuum extinction, for use when hydrogen populations are given explicitly (e.g. non-equilibrium ionisation or NLTE).\n\n\n\n\n\n","category":"type"},{"location":"#Muspel.StokesA-NTuple{8, Any}","page":"Home","title":"Muspel.StokesA","text":"Builds the reduced 4x4 Stokes propagation matrix, defined as:\n\nA = Î±_l / Î±_I âŽ¡0    Ï•Q   Ï•U   Ï•VâŽ¤\n              âŽœÏ•Q    0   ÏˆV  -ÏˆUâŽ¥\n              âŽœÏ•U  -ÏˆV    0   ÏˆQâŽ¥\n              âŽ£Ï•V   ÏˆU  -ÏˆQ    0âŽ¦\n\n\nwhere Î±_I = Î±_cont + Î±_line * Ï•I.\n\n\n\n\n\n","category":"method"},{"location":"#Muspel._assign_unit-Tuple{Dict}","page":"Home","title":"Muspel._assign_unit","text":"Return a value with a unit given a dictionary read from a YAML file.\n\n\n\n\n\n","category":"method"},{"location":"#Muspel._linear_coeffs-Tuple{Any, Any}","page":"Home","title":"Muspel._linear_coeffs","text":"Computes coefficients for linear piecewise interpolation.\n\n\n\n\n\n","category":"method"},{"location":"#Muspel._linear_stencil-Tuple{Any, Any, Any}","page":"Home","title":"Muspel._linear_stencil","text":"Get stencil for linear piecewise interpolation.\n\n\n\n\n\n","category":"method"},{"location":"#Muspel._read_broadening_single-Tuple{Dict, Vararg{Any, 5}}","page":"Home","title":"Muspel._read_broadening_single","text":"Reads individual broadening mechanisms and converts each to a multiplier constant and temperature exponent based on different recipes.\n\n\n\n\n\n","category":"method"},{"location":"#Muspel._read_transition-Tuple{Dict, Any, Any}","page":"Home","title":"Muspel._read_transition","text":"Helper function to parse transition upper and lower levels and compute wavelength. To be used with fields from the YAML atom format.\n\n\n\n\n\n","category":"method"},{"location":"#Muspel._spline_coeffs-Tuple{Any, Any}","page":"Home","title":"Muspel._spline_coeffs","text":"Computes coefficients for cubic spline interpolation.\n\n\n\n\n\n","category":"method"},{"location":"#Muspel._spline_stencil-Tuple{Any, Any, Any}","page":"Home","title":"Muspel._spline_stencil","text":"Gets stencil coordinates for cubic spline.\n\n\n\n\n\n","category":"method"},{"location":"#Muspel._w2-Tuple{T} where T<:AbstractFloat","page":"Home","title":"Muspel._w2","text":"Computes weights for linear integration of source function, approximating exp(-Î”Ï„) for very small and very large values of Î”Ï„.\n\n\n\n\n\n","category":"method"},{"location":"#Muspel.bezier3_coeffs-Tuple{T} where T<:AbstractFloat","page":"Home","title":"Muspel.bezier3_coeffs","text":"Compute interpolation coefficients for cubic BÃ©zier interpolation for a given optical depth interval Î´ and following de la Cruz Rodriguez & Piskunov (2013), after eq. (20).\n\nUses approximations for low or high optical depths to avoid numerical instabilities.\n\n\n\n\n\n","category":"method"},{"location":"#Muspel.blackbody_Î»-Union{Tuple{T2}, Tuple{T1}, Tuple{T1, T2}} where {T1<:Real, T2<:AbstractFloat}","page":"Home","title":"Muspel.blackbody_Î»","text":"Calculates the Blackbody (Planck) function per wavelength in nm and temperature in K. Outputs in kW m^-2 nm^-1.\n\n\n\n\n\n","category":"method"},{"location":"#Muspel.calc_line_1D!-Union{Tuple{M}, Tuple{T}, Tuple{AtomicLine, RTBuffer{T}, AbstractVector{M}, Atmosphere1D{1, T, A, V} where {A<:AbstractVector{T}, V<:AbstractVector{T}}, AbstractVector{T}, AbstractVector{T}, Interpolations.AbstractInterpolation{<:Number, 2}}} where {T<:AbstractFloat, M<:Real}","page":"Home","title":"Muspel.calc_line_1D!","text":"function calc_line_1D!(\n    line::AtomicLine,\n    buf::RTBuffer{T},\n    Î»::AbstractVector{T},\n    atm::Atmosphere1D{1, T},\n    n_up::AbstractVector{T},\n    n_lo::AbstractVector{T},\n    voigt_itp::Interpolations.AbstractInterpolation{<:Number, 2};\n    to_end::Bool=false,\n    initial_condition=:source,\n    calc_Ï„_one::Bool=false,\n)\n\nCalculate emerging disk-centre intensity for a single spectral line in a 1D atmosphere. Need to run calclineprep!() previously.\n\n\n\n\n\n","category":"method"},{"location":"#Muspel.calc_line_prep!-Union{Tuple{T}, Tuple{AtomicLine, RTBuffer{T}, Atmosphere1D{1, T, A, V} where {A<:AbstractVector{T}, V<:AbstractVector{T}}, ExtinctionItpNLTE{var\"#s47\", T2, ITP_2D, ITP_1D} where {var\"#s47\"<:Real, T2, ITP_2D<:(Interpolations.AbstractInterpolation{var\"#s47\", 2}), ITP_1D<:(Interpolations.AbstractInterpolation{var\"#s47\", 1})}}} where T<:AbstractFloat","page":"Home","title":"Muspel.calc_line_prep!","text":"Calculates the wavelength-independent quantities necessary for solving the RTE for a line: continuum extinction and emissivity, broadening, and Doppler width. They are saved into buf.\n\n\n\n\n\n","category":"method"},{"location":"#Muspel.calc_Î»line_MULTI-Union{Tuple{T}, Tuple{Union{Unitful.Quantity{T, ð‹, U}, Unitful.Level{L, S, Unitful.Quantity{T, ð‹, U}} where {L, S}} where U, Any, T, T, Union{Unitful.Quantity{T, ð‹ ð“^-1, U}, Unitful.Level{L, S, Unitful.Quantity{T, ð‹ ð“^-1, U}} where {L, S}} where U}} where T<:Real","page":"Home","title":"Muspel.calc_Î»line_MULTI","text":"Calculate line wavelengths using recipe from MULTI.\n\n\n\n\n\n","category":"method"},{"location":"#Muspel.calc_Î»line_RH-Union{Tuple{T}, Tuple{Union{Unitful.Quantity{T, ð‹, U}, Unitful.Level{L, S, Unitful.Quantity{T, ð‹, U}} where {L, S}} where U, Any, T, T, Union{Unitful.Quantity{T, ð‹ ð“^-1, U}, Unitful.Level{L, S, Unitful.Quantity{T, ð‹ ð“^-1, U}} where {L, S}} where U}} where T<:Real","page":"Home","title":"Muspel.calc_Î»line_RH","text":"Calculate line wavelengths using recipe from RH.\n\n\n\n\n\n","category":"method"},{"location":"#Muspel.calc_Ï„_cont!-Union{Tuple{T}, Tuple{Atmosphere1D{1, T, A, V} where {A<:AbstractVector{T}, V<:AbstractVector{T}}, AbstractVector{<:Real}, ExtinctionItpNLTE{var\"#s45\", T2, ITP_2D, ITP_1D} where {var\"#s45\"<:Real, T2, ITP_2D<:(Interpolations.AbstractInterpolation{var\"#s45\", 2}), ITP_1D<:(Interpolations.AbstractInterpolation{var\"#s45\", 1})}}} where T<:AbstractFloat","page":"Home","title":"Muspel.calc_Ï„_cont!","text":"Calculate continuum optical depth in the vertical direction, from the observer to the stellar interior. The wavelength is defined by Ïƒ_itp.\n\n\n\n\n\n","category":"method"},{"location":"#Muspel.calc_Ï„_one_height-Union{Tuple{T}, Tuple{AbstractVector{<:Real}, AbstractVector{T}}} where T<:Real","page":"Home","title":"Muspel.calc_Ï„_one_height","text":"Calculate height where Ï„=1 using linear interpolation\n\n\n\n\n\n","category":"method"},{"location":"#Muspel.cent_deriv-NTuple{5, Any}","page":"Home","title":"Muspel.cent_deriv","text":"Compute derivative of a monotonic interpolation function following Steffen (1990), eq. (11).\n\n\n\n\n\n","category":"method"},{"location":"#Muspel.create_Ïƒ_itp_LTE-Union{Tuple{T}, Tuple{Real, AbstractRange{T}, AbstractRange{T}, AtomicModel, AbstractVector{AtomicModel}, Vector{Vector{Interpolations.FilledExtrapolation}}}} where T<:Real","page":"Home","title":"Muspel.create_Ïƒ_itp_LTE","text":"create_Ïƒ_itp_LTE(\n    Î»::T,\n    log_temp::AbstractVector{T},\n    log_ne::AbstractVector{T},\n    H_atom::AtomicModel,\n    background_atoms::AbstractVector{AtomicModel},\n    atom_interpolants::Vector{Vector{Interpolations.FilledExtrapolation}},\n)\n\nCreate interpolant structure continuum cross section, for the case when hydrogen populations are not given explicitly (and are calculated using Saha). Includes cross sections from bound-free transition present in background atoms, plus the following sources of extinction:\n\n* sources from ÏƒH_continuum\n* H ff\n\nArguments\n\nÎ»: wavelength in nm.\nlog_temp: sequence of log10 temperature (K) for the table.\nlog_ne: sequence of log10 electron density (m^-3) for the table.\nH_atom: a hydrogen model atom to compute Saha ionisation fractions\nbackground_atoms : sequence of model atoms\natom_interpolants : sequence of bf interpolants corresponding to each background atom\n\n\n\n\n\n","category":"method"},{"location":"#Muspel.create_Ïƒ_itp_NLTE-Union{Tuple{T}, Tuple{Real, AbstractRange{T}, AbstractRange{T}, AbstractVector{AtomicModel}, Vector{Vector{Interpolations.FilledExtrapolation}}}} where T<:Real","page":"Home","title":"Muspel.create_Ïƒ_itp_NLTE","text":"create_Ïƒ_itp_NLTE(\n    Î»::Real,\n    log_temp::AbstractVector{T},\n    log_ne::AbstractVector{T},\n    background_atoms::AbstractVector{AtomicModel},\n    atom_interpolants::Vector{Vector{Interpolations.FilledExtrapolation}},\n)\n\nCreate interpolant structure continuum cross section, for the case of explicit hydrogen populations. Includes cross sections from bound-free transition present in background atoms, plus the following sources of extinction:\n\nHminus bf and ff\nH2+ molecule bf and ff\nH ff\n\nArguments\n\nÎ»: wavelength in nm.\nlog_temp: sequence of log10 temperature (K) for the table.\nlog_ne: sequence of log10 electron density (m^-3) for the table.\nbackground_atoms : sequence of model atoms\natom_interpolants : sequence of bf interpolants corresponding to each background atom\n\n\n\n\n\n","category":"method"},{"location":"#Muspel.damping-Union{Tuple{T}, Tuple{T, Real, Real}} where T<:Real","page":"Home","title":"Muspel.damping","text":"Damping constant for Î³ in rad / s, Î» and Î”Î»D in nm.\n\n\n\n\n\n","category":"method"},{"location":"#Muspel.doppler_width-Union{Tuple{T}, Tuple{Any, Any, T}} where T<:AbstractFloat","page":"Home","title":"Muspel.doppler_width","text":"Doppler width for mass in kg, temperature in K\n\n\n\n\n\n","category":"method"},{"location":"#Muspel.feautrier-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, AbstractVector{T}}} where T<:AbstractFloat","page":"Home","title":"Muspel.feautrier","text":"function feautrier(\n    z::Array{<:Unitful.Length{T}, 1},\n    Î±::Array{<:PerLength{T}, 1},\n    source_function::Array{<:Unitful.Quantity, 1}\n) where T <: AbstractFloat\n\nCalculate solution to radiative transfer equation using the Feautrier method. Uses algorithm from Rybicki & Hummer, 1991, A&A 245. Returns the height-dependent Feautrier variable P:\n\nP equiv 12 (I^+ + I^-)\n\nCurrently operates under the following assumptions:\n\nThe first index of the variables is the top of the atmosphere\nThe boundary conditions are zero radiation at the top and source function at the bottom\n\nTherefore, the emergent intensity is 2 * P[1], since I^-1=0.\n\nNot properly tested, use with care!\n\n\n\n\n\n","category":"method"},{"location":"#Muspel.g_JK-NTuple{6, Any}","page":"Home","title":"Muspel.g_JK","text":"Calculates LandÃ© factor from JK coupling.\n\n\n\n\n\n","category":"method"},{"location":"#Muspel.g_LS-Tuple{Any, Any, Any}","page":"Home","title":"Muspel.g_LS","text":"Calculates LandÃ© factor from LS coupling.\n\n\n\n\n\n","category":"method"},{"location":"#Muspel.g_eff-NTuple{4, Any}","page":"Home","title":"Muspel.g_eff","text":"Calculates the effective LandÃ© factor.\n\n\n\n\n\n","category":"method"},{"location":"#Muspel.g_jj-NTuple{5, Any}","page":"Home","title":"Muspel.g_jj","text":"Calculates LandÃ© factor from jj coupling.\n\n\n\n\n\n","category":"method"},{"location":"#Muspel.get_atoms_bf_interpolant-Tuple{AbstractVector{AtomicModel}}","page":"Home","title":"Muspel.get_atoms_bf_interpolant","text":"get_atoms_bf_interpolant(atoms::AbstractVector{AtomicModel})\n\nReturns interpolants for bound-free cross section data multiplied with abundances for each atom.\n\nArguments\n\natoms: A Vector of AtomicModels, with continua.\n\nReturns\n\ntables::Vector{Vector{Interpolations.FilledExtrapolation}}:   Interpolation functions.\n\nExamples\n\njulia> ATOM_PATH = \"/my/atoms/dir/\";\njulia> atoms = [\n    \"Al.yaml\",\n    \"C.yaml\",\n    \"Ca.yaml\",\n    \"Fe.yaml\",\n    \"H_6.yaml\",\n    \"He.yaml\",\n    \"KI.yaml\",\n    \"Mg.yaml\",\n    \"N.yaml\",\n    \"Na.yaml\",\n    \"NiI.yaml\",\n    \"O.yaml\",\n    \"S.yaml\",\n    \"Si.yaml\",\n];\njulia> background_atoms = Vector{AtomicModel}(undef, length(atoms))\njulia> for (index, atom_file) in enumerate(atoms)\n           background_atoms[index] = read_atom(join([ATOM_PATH, atom_file]))\n       end\njulia> atom_interpolants = get_atoms_bf_interpolant(background_atoms);\n\n\n\n\n\n","category":"method"},{"location":"#Muspel.get_zeeman_components-NTuple{6, Any}","page":"Home","title":"Muspel.get_zeeman_components","text":"Computes Zeeman strengths and shifts for the Ï€ and Ïƒ components.\n\n\n\n\n\n","category":"method"},{"location":"#Muspel.get_Ïƒ_itp-Tuple{Muspel.AbstractAtmos, Real, Vector{String}}","page":"Home","title":"Muspel.get_Ïƒ_itp","text":"get_Ïƒ_itp(atmos::Atmosphere, Î»::Real, atom_files::Vector{String}; npts=100)\n\nConstruct monochromatic continuum cross section interpolant for a given atmosphere, and wavelength Î» in nm. Includes all the processes included in create_Ïƒ_itp_NLTE, plus all the bound-free cross sections present in all model atom files in the list atom_files.\n\nHere atmos is used only to get the minimum and maximum values of temperature and electron density, to build the interpolation table. The number of points in the table (both for log(temperature) and log(electron density)) is given by npts (default 100).\n\nReturns\n\nExtinctionItpNLTE: continuum cross section interpolant for explicit hydrogen populations. To be used in function Î±_cont.\n\nExamples\n\njulia> ATOM_PATH = AtomicData.get_atom_dir();\njulia> bckgr_atoms = [\n    \"Al.yaml\",\n    \"C.yaml\",\n    \"Ca.yaml\",\n    \"Fe.yaml\",\n    \"H_6.yaml\",\n    \"He.yaml\",\n    \"KI.yaml\",\n    \"Mg.yaml\",\n    \"N.yaml\",\n    \"Na.yaml\",\n    \"NiI.yaml\",\n    \"O.yaml\",\n    \"S.yaml\",\n    \"Si.yaml\",\n];\njulia> atom_files = [joinpath(ATOM_PATH, a) for a in bckgr_atoms];\njulia> atmos = atmos = read_atmos_rh(MY_ATMOS);\njulia> itp = get_Ïƒ_itp(atmos, 500.0, atom_files)\n\n\n\n\n\n","category":"method"},{"location":"#Muspel.h_ionfrac_saha-Union{Tuple{T}, Tuple{T, Real}} where T<:Real","page":"Home","title":"Muspel.h_ionfrac_saha","text":"h_ionfrac_saha(temp::T, electron_density::T)::T where {T <: Real}\n\nCalculate ionisation fraction of hydrogen using Saha.\n\n\n\n\n\n","category":"method"},{"location":"#Muspel.incline_atmos-Tuple{Muspel.AbstractAtmos3D, Real, Real}","page":"Home","title":"Muspel.incline_atmos","text":"incline_atmos(atmos_in::AbstractAtmos3D, Î¼::Real, Ï†::Real)\n\nTransforms a 3D atmosphere into an inclined coordinate system, given by a rotation by a polar angle Î¸, given by Î¼ = cos(Î¸) and an azimuthal angle Ï†. The output is an atmosphere of the same type, where the quantities have been interpolated to the same number of depth points and the vector quantities projected onto the new axes.\n\nAssumes the following:\n\nOrder of the axes in 3D arrays is (z, y, x)\nHorizontally periodic boundary conditions\nThe first index in the height direction is fixed in the polar rotation\nA right handed system, so that:\n\n      z  â†‘.           - Î¸ is the clockwise polar rotation from the z axis\n         |  .         - Ï† is the clockwise azimuthal rotation from the x axis\n         |    .\n         |      .\n         |        *\n         |      . .\n         | Î¸  .   .\n         |  .     .\n         |.       .\n         +--------.-----â†’ y\n        /  .      .   /\n       /  Ï†  .    .\n      /         . . /\n     /_ _ _ _ _ _ .\n    /\n  x\n\n\n\n\n\n","category":"method"},{"location":"#Muspel.incline_data!-Tuple{AbstractArray{<:Real, 3}, AbstractArray{<:Real, 3}, AbstractVector, Vararg{Real, 4}}","page":"Home","title":"Muspel.incline_data!","text":"incline_data!(\n        data_in::AbstractArray{<: Real, 3},\n        data_out::AbstractArray{<: Real, 3},\n        z::AbstractVector,\n        dx::Real,\n        dy::Real,\n        Î¼::Real,\n        Ï•::Real;\n        interpolation=:linear\n)\n\nTransforms a 3D array into an inclined coordinate system, according to a polar angle given by Î¼ = cos(Î¸), and an azimuthal angle Ï•. Writes output into data_out, and uses either linear piecewise or cubic spline interpolation depending on interpolation (:linear or :cubic).\n\nHeight must be the first dimension in data_in and data_out.\n\n\n\n\n\n","category":"method"},{"location":"#Muspel.incline_data_inv!-Tuple{AbstractArray{<:Real, 3}, AbstractVector, Vararg{Real, 4}}","page":"Home","title":"Muspel.incline_data_inv!","text":"incline_data_inv!(\n        data::AbstractArray{<: Real, 3},\n        z::AbstractVector,\n        dx::Real,\n        dy::Real,\n        Î¼::Real,\n        Ï•::Real\n)\n\nTransforms a 3D array into an inclined coordinate system, according to a polar angle given by Î¼ = cos(Î¸), and an azimuthal angle Ï•. Uses cubic spline interpolation, and updates data in-place. Based on trnslt.f90 from Ã…ke Nordlund.\n\nThis version only works if height is the last dimension in data. This is 3-5x faster than incline_data! because the loop order is optimised for this memory configuration.\n\n\n\n\n\n","category":"method"},{"location":"#Muspel.parse_label_LS-Tuple{Any}","page":"Home","title":"Muspel.parse_label_LS","text":"Parses an atomic level label in RH format, to extract the atomic numbers S and L.\n\n\n\n\n\n","category":"method"},{"location":"#Muspel.piecewise_1D_bezier3!-Union{Tuple{T}, NTuple{4, AbstractVector{T}}} where T<:AbstractFloat","page":"Home","title":"Muspel.piecewise_1D_bezier3!","text":"function piecewise_1D_bezier3!(\n    z::AbstractVector{T},\n    Î±::AbstractVector{T},\n    source::AbstractVector{T},  # source function\n    intensity::AbstractVector{T};\n    to_end::Bool=false,\n    initial_condition=:source\n) where T <: AbstractFloat\n\nCompute piecewise integration of the radiative transfer equation, assuming a cubic BÃ©zier integration of the source function, following de la Cruz Rodriguez & Piskunov (2013), and adapted from the implementation in RH / STiC. Calculates for a given height z, extinction Î± and source_function and intensity (existing array where the output will be saved into). The optional keyword argument to_end defines the direction of the integration: if false (default) will start to integrate intensity from the last element to the first, and if true will integrate from the first element to the last. initial_condition can take two values: :zero for no radiation, or :source (default) to take the source function at the starting point.\n\n\n\n\n\n","category":"method"},{"location":"#Muspel.piecewise_1D_linear!-Union{Tuple{T}, NTuple{4, AbstractVector{T}}} where T<:AbstractFloat","page":"Home","title":"Muspel.piecewise_1D_linear!","text":"piecewise_1D_linear!(\n    z::AbstractVector{T},\n    Î±::AbstractVector{T},\n    source_function::AbstractVector{T},\n    intensity::AbstractVector{T};\n    to_end::Bool=false,\n    initial_condition=:source\n) where T <: AbstractFloat\n\nCompute piecewise integration of the radiative transfer equation, assuming linear integration of the source function, for a given height z, extinction Î± and source_function and intensity (existing array where the output will be saved into). The optional keyword argument to_end defines the direction of the integration: if false (default) will start to integrate intensity from the last element to the first, and if true will integrate from the first element to the last. initial_condition can take two values: :zero for no radiation, or :source (default) to take the source function at the starting point.\n\n\n\n\n\n","category":"method"},{"location":"#Muspel.piecewise_1D_linear-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, AbstractVector{T}}} where T<:AbstractFloat","page":"Home","title":"Muspel.piecewise_1D_linear","text":"piecewise_1D_linear(\n    z::AbstractVector{T},\n    Î±::AbstractVector{T},\n    source_function::AbstractVector{T};\n    to_end::Bool=false,\n    initial_condition=:source\n) where T <: AbstractFloat\n\nDEPRECATED, use piecewise1Dlinear! Compute piecewise integration of the radiative transfer equation, assuming linear integration of the source function, for a given height z, extinction Î± and source_function. The optional keyword argument to_end defines the direction of the integration: if false (default) will start to integrate intensity from the last element to the first, and if true will integrate from the first element to the last. initial_condition can take two values: :zero for no radiation, or :source (default) to take the source function at the starting point.\n\n\n\n\n\n","category":"method"},{"location":"#Muspel.piecewise_1D_nn-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, AbstractVector{T}}} where T<:AbstractFloat","page":"Home","title":"Muspel.piecewise_1D_nn","text":"piecewise_1D_nn(\n    z::AbstractVector{T},\n    Î±::AbstractVector{T},\n    source_function::AbstractVector{T};\n    to_end::Bool=false,\n    initial_condition=:source\n) where T <: AbstractFloat\n\nCompute piecewise integration of the radiative transfer equation, assuming nearest-neighbour integration of the source function, for a given height z, extinction Î± and source_function. The optional keyword argument to_end defines the direction of the integration: if false (default) will start to integrate intensity from the last element to the first, and if true will integrate from the first element to the last. initial_condition can take two values: :zero for no radiation, or :source (default) to take the source function at the starting point.\n\n\n\n\n\n","category":"method"},{"location":"#Muspel.project_vector!-Union{Tuple{A}, Tuple{A, A, A, Real, Real}} where A<:(AbstractArray{<:Real})","page":"Home","title":"Muspel.project_vector!","text":"project_vector!(vx::A, vy::A, vz::A, Î¼::Real, Ï†::Real)\n\nProjects a vector in 3D space according to the rotation by an polar angle Î¸, given by Î¼ = cos(Î¸) and an azimuthal angle Ï†. The inputs are the vector components in the x, y, and z axes, for an array of a given size (typically 3D).\n\nAssumes the following:\n\nÎ¸ is the clockwise polar rotation from the z axis\nÏ† is the clockwise azimuthal rotation from the x axis\nThe rotation of the vector is the same as the (inverse) rotation from the axes (x, y, z) into a new system (x', y', z') given by the rotation matrix:\n\n               Polar          Azimuthal\n   âŽ¡x'âŽ¤ = âŽ¡cosÎ¸  0  -sinÎ¸âŽ¤âŽ¡ cosÏ†  sinÏ†  0âŽ¤âŽ¡xâŽ¤\n   âŽœy'âŽ¥   âŽœ  0   1    0  âŽ¥âŽœ-sinÏ†  cosÏ†  0âŽ¥âŽœyâŽ¥\n   âŽ£z'âŽ¦   âŽ£sinÎ¸  0   cosÎ¸âŽ¦âŽ£   0     0   1âŽ¦âŽ£zâŽ¦\n\n   âŒˆx'âŽ¤ = âŽ¡cosÎ¸cosÏ†  cosÎ¸sinÏ†  -sinÏ†âŽ¤âŽ¡xâŽ¤\n   |y'âŽ¥   âŽœ -sinÏ†      cosÏ†       0 âŽ¥âŽœyâŽ¥\n   âŒŠz'âŽ¦   âŽ£sinÎ¸cosÏ†  sinÎ¸sinÏ†   cosÎ¸âŽ¦âŽ£zâŽ¦\n\n\n\n\n\n","category":"method"},{"location":"#Muspel.read_atmos_hpops_multi3d-Tuple{Any, Any, Any}","page":"Home","title":"Muspel.read_atmos_hpops_multi3d","text":"Reads atmosphere in the input format of MULTI3D, at the same time as the hydrogen populations. Only works for a H NLTE run. Only Float32 files are supported at the moment.\n\n\n\n\n\n","category":"method"},{"location":"#Muspel.read_atmos_hpops_rh-Tuple{Any, Any}","page":"Home","title":"Muspel.read_atmos_hpops_rh","text":"Reads RH atmosphere. Returns always in single precision.\n\n\n\n\n\n","category":"method"},{"location":"#Muspel.read_atmos_multi3d-Tuple{Any, Any}","page":"Home","title":"Muspel.read_atmos_multi3d","text":"Reads atmosphere in the input format of MULTI3D. Only Float32 atmospheres are supported at the moment.\n\n\n\n\n\n","category":"method"},{"location":"#Muspel.read_atmos_rh-Tuple{Any}","page":"Home","title":"Muspel.read_atmos_rh","text":"Reads RH atmosphere. Returns always in single precision.\n\n\n\n\n\n","category":"method"},{"location":"#Muspel.read_atmos_rh_index-Tuple{Any}","page":"Home","title":"Muspel.read_atmos_rh_index","text":"Reads RH atmosphere. Returns always in single precision. Slightly slower version that supports selecting timestep.\n\n\n\n\n\n","category":"method"},{"location":"#Muspel.read_atom-Tuple{Any}","page":"Home","title":"Muspel.read_atom","text":"Reads atom in YAML format, returns AtomicModel structure\n\n\n\n\n\n","category":"method"},{"location":"#Muspel.read_continuum-Tuple{Dict, Any, Any, Any}","page":"Home","title":"Muspel.read_continuum","text":"Reads continuum transition data in a Dict read from a YAML-formatted atom file. Needs level energies Ï‡, ionisation stages, and level ids from atom file.\n\n\n\n\n\n","category":"method"},{"location":"#Muspel.read_line-Tuple{Dict, Vararg{Any, 6}}","page":"Home","title":"Muspel.read_line","text":"Reads spectral line data in a Dict read from a YAML-formatted atom file. Needs level energies Ï‡, ionisation stages, labels, level ids and atomic mass from atom file.\n\n\n\n\n\n","category":"method"},{"location":"#Muspel.read_mesh-Tuple{Any}","page":"Home","title":"Muspel.read_mesh","text":"Reads mesh file from Bifrost or MULTI3D.\n\n\n\n\n\n","category":"method"},{"location":"#Muspel.read_pops_multi3d-NTuple{5, Any}","page":"Home","title":"Muspel.read_pops_multi3d","text":"Reads NLTE populations from MULTI3D output. Does NOT permute dims. Only Float32 files are supported at the moment.\n\n\n\n\n\n","category":"method"},{"location":"#Muspel.read_pops_rh-Tuple{Any, Any}","page":"Home","title":"Muspel.read_pops_rh","text":"Reads array with populations for a given species.\n\n\n\n\n\n","category":"method"},{"location":"#Muspel.saha_boltzmann!-Union{Tuple{T}, Tuple{N}, Tuple{StaticArraysCore.SVector{N, <:Real}, StaticArraysCore.SVector{N, <:Real}, StaticArraysCore.SVector{N, <:Real}, Real, Real, Real, AbstractVector{T}}} where {N, T<:AbstractFloat}","page":"Home","title":"Muspel.saha_boltzmann!","text":"function saha_boltzmann!(\n    Ï‡::SVector,\n    g::SVector,\n    stage::SVector,\n    temperature::T,\n    electron_density::T,\n    atom_density::T,\n    populations::AbstractArray{T, 1},\n) where T <: AbstractFloat\n\nfunction saha_boltzmann!(\n    atom::AtomicModel,\n    temperature::T,\n    electron_density::T,\n    atom_density::T,\n    populations::AbstractArray{T, 1},\n) where T <: AbstractFloat\n\nInplace version of saha_boltzmann. Calculates atomic level populations according to the Saha-Boltzmann distribution, placing them in an existingpopulations` array.\n\nArguments\n\nÏ‡: level energies in J\ng: statistical weights of levels\nstage: ionisation stage of each level (starting at 1 for neutral)\nOr, instead of the three above, an instance of AtomicModel\ntemperature: temperature in Kelvin\nelectron_density: electron density in m^-3\natom_density: total number density (in all levels) of target species\npopulations: 1D array for output, must be same length as number of levels\n\n\n\n\n\n","category":"method"},{"location":"#Muspel.saha_boltzmann-Union{Tuple{T}, Tuple{N}, Tuple{StaticArraysCore.SVector{N, <:Real}, StaticArraysCore.SVector{N, <:Real}, StaticArraysCore.SVector{N, <:Real}, T, T, Real}} where {N, T<:AbstractFloat}","page":"Home","title":"Muspel.saha_boltzmann","text":"function saha_boltzmann(\n    Ï‡::SVector,\n    g::SVector,\n    stage::SVector,\n    temperature::T,\n    electron_density::T,\n    atom_density::T\n) where T <: AbstractFloat\n\nfunction saha_boltzmann(\n    atom::AtomicModel,\n    temperature::T,\n    electron_density::T,\n    atom_density::T,\n) where T <: AbstractFloat\n\nCalculates atomic level populations according to the Saha-Boltzmann distribution.\n\nArguments\n\nÏ‡: level energies in J\ng: statistical weights of levels\nstage: ionisation stage of each level (starting at 1 for neutral)\nOr, instead of the three above, an instance of AtomicModel\ntemperature: temperature in Kelvin\nelectron_density: electron density in m^-3\natom_density: total number density (in all levels) of target species\n\nReturns\n\npopulations: MVector{nlevels} with relative level populations in m^-3\n\n\n\n\n\n","category":"method"},{"location":"#Muspel.stokes_profiles-Union{Tuple{T}, Tuple{AtomicLine, Interpolations.AbstractInterpolation{<:Number, 2}, Vararg{T, 6}}} where T<:AbstractFloat","page":"Home","title":"Muspel.stokes_profiles","text":"Computes line profiles under Zeeman effect, for all Stokes parameters and also including magneto-optical effects.\n\nReturns a 7-element tuple with: (Ï•I, Ï•Q, Ï•U, Ï•V, ÏˆQ, ÏˆU, ÏˆV).\n\nTakes into account the symmetry of H and anti-symmetry of L, so voigt_itp only needs to cover positive values of v.\n\n\n\n\n\n","category":"method"},{"location":"#Muspel.zeeman_strength-NTuple{4, Any}","page":"Home","title":"Muspel.zeeman_strength","text":"Calculates strengths of Zeeman components. These strengths are normalised.\n\n\n\n\n\n","category":"method"},{"location":"#Muspel.Î±_cont-Union{Tuple{T}, Tuple{ExtinctionItpLTE{var\"#s48\", T2, ITP_2D} where {var\"#s48\"<:Real, T2, ITP_2D<:(Interpolations.AbstractInterpolation{var\"#s48\", 2})}, T, T, T}} where T<:AbstractFloat","page":"Home","title":"Muspel.Î±_cont","text":"Î±_cont(\n    itp::ExtinctionItpLTE{T},\n    temperature::T,\n    electron_density::T,\n    hydrogen_density::T,\n)\n\nCalculates continuum extinction in m^-1 using interpolant structure.\n\nArguments\n\nitp: Interpolant structure for a given wavelength, hydrogen LTE case\ntemperature: Temperature in K.\nelectron_density: Electron number density in m^-3.\nhydrogen_density: Number density of hydrogen atoms (all stages), unit m^-3.\n\nExamples\n\njulia> npts = 100;\njulia> log_temp = LinRange(3.3, 5, npts);\njulia> log_ne = LinRange(15, 23, npts);\njulia> H_3 = read_atom(\"H_3.yaml\");\njulia> itp_lte = create_Ïƒ_itp_LTE(500., log_temp, log_ne, H_3,\n                                  background_atoms, atom_interpolants);\njulia> Î±_cont(itp_lte, 6000., 1e20, 1e20)\n3.59972810095902e-8\n\n\n\n\n\n","category":"method"},{"location":"#Muspel.Î±_cont-Union{Tuple{T}, Tuple{ExtinctionItpNLTE{var\"#s48\", T2, ITP_2D, ITP_1D} where {var\"#s48\"<:Real, T2, ITP_2D<:(Interpolations.AbstractInterpolation{var\"#s48\", 2}), ITP_1D<:(Interpolations.AbstractInterpolation{var\"#s48\", 1})}, Vararg{T, 4}}} where T<:AbstractFloat","page":"Home","title":"Muspel.Î±_cont","text":"Î±_cont(\n    itp::ExtinctionItpNLTE{T},\n    temperature::T,\n    electron_density::T,\n    h_neutral_density::T,\n    proton_density::T,\n)\n\nCalculates continuum extinction in m^-1 using interpolant structure.\n\nArguments\n\nitp: Interpolant structure for a given wavelength, hydrogen NLTE case\ntemperature: Temperature in K.\nelectron_density: Electron number density in m^-3.\nh_neutral_density: Number density of neutral hydrogen in m^-3.\nproton_density: Proton number density in m^-3.\n\nExamples\n\njulia> npts = 100;\njulia> log_temp = LinRange(3.3, 5, npts);\njulia> log_ne = LinRange(15, 23, npts);\njulia> itp_nlte = create_Ïƒ_itp_NLTE(500., log_temp, log_ne,\n                                  background_atoms, atom_interpolants);\njulia> Î±_cont(itp_nlte, 6000., 1e20, 1e20, 4.2462e15)\n3.5998540603635895e-8\n\n\n\n\n\n","category":"method"},{"location":"#Muspel.Î±_cont_no_itp-Union{Tuple{T}, NTuple{5, T}} where T<:AbstractFloat","page":"Home","title":"Muspel.Î±_cont_no_itp","text":"function Î±_cont_no_itp(\n    Î»::T,\n    temperature::T,\n    electron_density::T,\n    h_ground_density::T,\n    h_neutral_density::T,\n    proton_density::T\n) where T <: AbstractFloat\n\nCalculates continuum extinction without using an interpolation table. Does not include bound-free processes from background atoms.\n\nArguments\n\nÎ»: Wavelength in nm.\ntemperature: Temperature in K.\nelectron_density: Electron number density in m^-3.\nh_ground_density: Number density of hydrogen in the ground state, unit m^-3.\nh_neutral_density: Number density of neutral hydrogen, unit m^-3.\nproton_density: Proton number density in m^-3.\n\nReturns\n\nÎ±: Continuous extinction (Float) in m^-1.\n\n\n\n\n\n","category":"method"},{"location":"#Muspel.Î³_g-Tuple{Any, Any, Any}","page":"Home","title":"Muspel.Î³_g","text":"Utility function to compute LandÃ© factors from various types of coupling. From pp. 76-77 of Landi Degl'Innocenti & Landolfi (2004).\n\n\n\n\n\n","category":"method"},{"location":"#Muspel.ÏƒH_atoms_bf-Union{Tuple{T}, Tuple{Vector{Vector{Interpolations.FilledExtrapolation}}, AbstractVector{AtomicModel}, Real, T, T}} where T<:AbstractFloat","page":"Home","title":"Muspel.ÏƒH_atoms_bf","text":"ÏƒH_atoms_bf(\n    Ïƒ_atom_tables::Vector{Vector{Interpolations.FilledExtrapolation}},\n    atoms::AbstractVector{AtomicModel},\n    Î»::T,\n    temperature::T,\n    electron_density::T\n) where T <: AbstractFloat\n\nCompute the bound-free cross-sections per hydrogen atom from bf transitions in model atoms.\n\nArguments\n\natom_interpolants: Interpolation functions from getatomsbf_interpolant().\natoms: A vector of AtomicModels with continua.\nÎ»: Wavelength in nm.\ntemperature: Temperature in K.\nelectron_density: Number density in m^-3.\n\nReturns\n\nÏƒ_Î»: Total cross section per hydrogen atom. Corrected for stimulated emission.\n\n\n\n\n\n","category":"method"},{"location":"#Muspel.ÏƒH_continuum-Union{Tuple{T}, Tuple{Real, T, T, Real}} where T<:AbstractFloat","page":"Home","title":"Muspel.ÏƒH_continuum","text":"ÏƒH_continuum(Î»::T, temperature::T, electron_density::T, ion_frac::T)\n\nCompute continuum cross sections in m^2 per hydrogen atom.\n\nArguments\n\nÎ»: wavelength in nm.\ntemperature: temperature in K.\nelectron_density: number density in m^-3.\nion_frac : ionisation fraction.\n\n\n\n\n\n","category":"method"}]
}
