var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = Muspel","category":"page"},{"location":"#Muspel","page":"Home","title":"Muspel","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for Muspel.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [Muspel]","category":"page"},{"location":"#Muspel.ExtinctionItpLTE","page":"Home","title":"Muspel.ExtinctionItpLTE","text":"Interpolant structure for continuum extinction, for use when hydrogen populations are computed in LTE (simplifies calculations).\n\n\n\n\n\n","category":"type"},{"location":"#Muspel.ExtinctionItpNLTE","page":"Home","title":"Muspel.ExtinctionItpNLTE","text":"Interpolant structure for continuum extinction, for use when hydrogen populations are given explicitly (e.g. non-equilibrium ionisation or NLTE).\n\n\n\n\n\n","category":"type"},{"location":"#Muspel._assign_unit-Tuple{Dict}","page":"Home","title":"Muspel._assign_unit","text":"Return a value with a unit given a dictionary read from a YAML file.\n\n\n\n\n\n","category":"method"},{"location":"#Muspel._read_broadening_single-Tuple{Dict, Any, Any, Any, Any, Any}","page":"Home","title":"Muspel._read_broadening_single","text":"Reads individual broadening mechanisms and converts each to a multiplier constant and temperature exponent based on different recipes.\n\n\n\n\n\n","category":"method"},{"location":"#Muspel._read_transition-Tuple{Dict, Any, Any}","page":"Home","title":"Muspel._read_transition","text":"Helper function to parse transition upper and lower levels and compute wavelength. To be used with fields from the YAML atom format.\n\n\n\n\n\n","category":"method"},{"location":"#Muspel._w2-Tuple{T} where T<:AbstractFloat","page":"Home","title":"Muspel._w2","text":"Computes weights for linear integration of source function, approximating exp(-) for very small and very large values of .\n\n\n\n\n\n","category":"method"},{"location":"#Muspel.calc_位line_MULTI-Union{Tuple{T}, Tuple{Union{Unitful.Quantity{T, , U}, Unitful.Level{L, S, Unitful.Quantity{T, , U}} where {L, S}} where U, Any, T, T, Union{Unitful.Quantity{T,  ^-1, U}, Unitful.Level{L, S, Unitful.Quantity{T,  ^-1, U}} where {L, S}} where U}} where T<:Real","page":"Home","title":"Muspel.calc_位line_MULTI","text":"Calculate line wavelengths using recipe from MULTI.\n\n\n\n\n\n","category":"method"},{"location":"#Muspel.calc_位line_RH-Union{Tuple{T}, Tuple{Union{Unitful.Quantity{T, , U}, Unitful.Level{L, S, Unitful.Quantity{T, , U}} where {L, S}} where U, Any, T, T, Union{Unitful.Quantity{T,  ^-1, U}, Unitful.Level{L, S, Unitful.Quantity{T,  ^-1, U}} where {L, S}} where U}} where T<:Real","page":"Home","title":"Muspel.calc_位line_RH","text":"Calculate line wavelengths using recipe from RH.\n\n\n\n\n\n","category":"method"},{"location":"#Muspel.create__itp_LTE-Union{Tuple{T}, Tuple{T, AbstractRange{T}, AbstractRange{T}, AtomicModel, AbstractVector{AtomicModel}, Vector{Vector{Interpolations.FilledExtrapolation}}}} where T<:AbstractFloat","page":"Home","title":"Muspel.create__itp_LTE","text":"create__itp_LTE(\n    位::T,\n    log_temp::AbstractVector{T},\n    log_ne::AbstractVector{T},\n    H_atom::AtomicModel,\n    background_atoms::AbstractVector{AtomicModel},\n    atom_interpolants::Vector{Vector{Interpolations.FilledExtrapolation}},\n)\n\nCreate  interpolant structure for the case of LTE hydrogen populations.\n\nArguments\n\n位: wavelength in nm.\nlog_temp: sequence of log10 temperature (K) for the table.\nlog_ne: sequence of log10 electron density (m^-3) for the table.\nH_atom: a hydrogen model atom to compute Saha ionisation fractions\nbackground_atoms : sequence of model atoms\natom_interpolants : sequence of bf interpolants corresponding to each background atom\n\n\n\n\n\n","category":"method"},{"location":"#Muspel.create__itp_NLTE-Union{Tuple{T}, Tuple{T, AbstractRange{T}, AbstractRange{T}, AbstractVector{AtomicModel}, Vector{Vector{Interpolations.FilledExtrapolation}}}} where T<:AbstractFloat","page":"Home","title":"Muspel.create__itp_NLTE","text":"create__itp_NLTE(\n    位::T,\n    log_temp::AbstractVector{T},\n    log_ne::AbstractVector{T},\n    background_atoms::AbstractVector{AtomicModel},\n    atom_interpolants::Vector{Vector{Interpolations.FilledExtrapolation}},\n)\n\nCreate  interpolant structure for the case of LTE hydrogen populations.\n\nArguments\n\n位: wavelength in nm.\nlog_temp: sequence of log10 temperature (K) for the table.\nlog_ne: sequence of log10 electron density (m^-3) for the table.\nbackground_atoms : sequence of model atoms\natom_interpolants : sequence of bf interpolants corresponding to each background atom\n\n\n\n\n\n","category":"method"},{"location":"#Muspel.feautrier-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, AbstractVector{T}}} where T<:AbstractFloat","page":"Home","title":"Muspel.feautrier","text":"function feautrier(\n    z::Array{<:Unitful.Length{T}, 1},\n    伪::Array{<:PerLength{T}, 1},\n    source_function::Array{<:Unitful.Quantity, 1}\n) where T <: AbstractFloat\n\nCalculate solution to radiative transfer equation using the Feautrier method. Uses algorithm from Rybicki & Hummer, 1991, A&A 245. Returns the height-dependent Feautrier variable P:\n\nP equiv 12 (I^+ + I^-)\n\nCurrently operates under the following assumptions:\n\nThe first index of the variables is the top of the atmosphere\nThe boundary conditions are zero radiation at the top and source function at the bottom\n\nTherefore, the emergent intensity is 2 * P[1], since I^-1=0.\n\nNot properly tested, use with care!\n\n\n\n\n\n","category":"method"},{"location":"#Muspel.get_atoms_bf_interpolant-Tuple{AbstractVector{AtomicModel}}","page":"Home","title":"Muspel.get_atoms_bf_interpolant","text":"get_atoms_bf_interpolant(atoms::AbstractVector{AtomicModel})\n\nReturns interpolants for bound-free cross section data multiplied with abundances for each atom.\n\nArguments\n\natoms: A Vector of AtomicModels, with continua.\n\nReturns\n\ntables::Vector{Vector{Interpolations.FilledExtrapolation}}:   Interpolation functions.\n\nExamples\n\njulia> ATOM_PATH = \"/my/atoms/dir/\";\njulia> atoms = [\n    \"Al.yaml\",\n    \"C.yaml\",\n    \"Ca.yaml\",\n    \"Fe.yaml\",\n    \"H_6.yaml\",\n    \"He.yaml\",\n    \"KI_fine.yaml\",\n    \"LiI.yaml\",\n    \"Mg.yaml\",\n    \"N.yaml\",\n    \"Na.yaml\",\n    \"NiI.yaml\",\n    \"O.yaml\",\n    \"S.yaml\",\n    \"Si.yaml\",\n];\njulia> background_atoms = Vector{AtomicModel}(undef, length(atoms))\njulia> for (index, atom_file) in enumerate(atoms)\n           background_atoms[index] = read_atom(join([ATOM_PATH, atom_file]))\n       end\njulia> atom_interpolants = get_atoms_bf_interpolant(background_atoms);\n\n\n\n\n\n","category":"method"},{"location":"#Muspel.piecewise_1D_linear-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, AbstractVector{T}}} where T<:AbstractFloat","page":"Home","title":"Muspel.piecewise_1D_linear","text":"piecewise_1D_linear(\n    z::AbstractVector{T},\n    伪::AbstractVector{T},\n    source_function::AbstractVector{T};\n    to_end::Bool=false,\n    initial_condition=:source\n) where T <: AbstractFloat\n\nCompute piecewise integration of the radiative transfer equation, assuming linear integration of the source function, for a given height z, extinction 伪 and source_function. The optional keyword argument to_end defines the direction of the integration: if false (default) will start to integrate intensity from the last element to the first, and if true will integrate from the first element to the last. initial_condition can take two values: :zero for no radiation, or :source (default) to take the source function at the starting point.\n\n\n\n\n\n","category":"method"},{"location":"#Muspel.piecewise_1D_nn-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, AbstractVector{T}}} where T<:AbstractFloat","page":"Home","title":"Muspel.piecewise_1D_nn","text":"piecewise_1D_nn(\n    z::AbstractVector{T},\n    伪::AbstractVector{T},\n    source_function::AbstractVector{T};\n    to_end::Bool=false,\n    initial_condition=:source\n) where T <: AbstractFloat\n\nCompute piecewise integration of the radiative transfer equation, assuming nearest-neighbour integration of the source function, for a given height z, extinction 伪 and source_function. The optional keyword argument to_end defines the direction of the integration: if false (default) will start to integrate intensity from the last element to the first, and if true will integrate from the first element to the last. initial_condition can take two values: :zero for no radiation, or :source (default) to take the source function at the starting point.\n\n\n\n\n\n","category":"method"},{"location":"#Muspel.read_atom-Tuple{Any}","page":"Home","title":"Muspel.read_atom","text":"Reads atom in YAML format, returns AtomicModel structure\n\n\n\n\n\n","category":"method"},{"location":"#Muspel.read_continuum-Tuple{Dict, Any, Any, Any}","page":"Home","title":"Muspel.read_continuum","text":"Reads continuum transition data in a Dict read from a YAML-formatted atom file. Needs level energies , ionisation stages, and level ids from atom file.\n\n\n\n\n\n","category":"method"},{"location":"#Muspel.read_line-Tuple{Dict, Any, Any, Any, Any, Any, Any}","page":"Home","title":"Muspel.read_line","text":"Reads spectral line data in a Dict read from a YAML-formatted atom file. Needs level energies , ionisation stages, labels, level ids and atomic mass from atom file.\n\n\n\n\n\n","category":"method"},{"location":"#Muspel.saha_boltzmann!-Union{Tuple{T}, Tuple{StaticArraysCore.SVector, StaticArraysCore.SVector, StaticArraysCore.SVector, T, T, T, AbstractVector{T}}} where T<:AbstractFloat","page":"Home","title":"Muspel.saha_boltzmann!","text":"function saha_boltzmann!(\n    ::SVector,\n    g::SVector,\n    stage::SVector,\n    temperature::T,\n    electron_density::T,\n    atom_density::T,\n    populations::AbstractArray{T, 1},\n) where T <: AbstractFloat\n\nfunction saha_boltzmann!(\n    atom::AtomicModel,\n    temperature::T,\n    electron_density::T,\n    atom_density::T,\n    populations::AbstractArray{T, 1},\n) where T <: AbstractFloat\n\nInplace version of saha_boltzmann. Calculates atomic level populations according to the Saha-Boltzmann distribution, placing them in an existingpopulations` array.\n\nArguments\n\n: level energies in J\ng: statistical weights of levels\nstage: ionisation stage of each level (starting at 1 for neutral)\nOr, instead of the three above, an instance of AtomicModel\ntemperature: temperature in Kelvin\nelectron_density: electron density in m^-3\natom_density: total number density (in all levels) of target species\npopulations: 1D array for output, must be same length as number of levels\n\n\n\n\n\n","category":"method"},{"location":"#Muspel.saha_boltzmann-Union{Tuple{T}, Tuple{StaticArraysCore.SVector, StaticArraysCore.SVector, StaticArraysCore.SVector, T, T, T}} where T<:AbstractFloat","page":"Home","title":"Muspel.saha_boltzmann","text":"function saha_boltzmann(\n    ::SVector,\n    g::SVector,\n    stage::SVector,\n    temperature::T,\n    electron_density::T,\n    atom_density::T\n) where T <: AbstractFloat\n\nfunction saha_boltzmann(\n    atom::AtomicModel,\n    temperature::T,\n    electron_density::T,\n    atom_density::T,\n) where T <: AbstractFloat\n\nCalculates atomic level populations according to the Saha-Boltzmann distribution.\n\nArguments\n\n: level energies in J\ng: statistical weights of levels\nstage: ionisation stage of each level (starting at 1 for neutral)\nOr, instead of the three above, an instance of AtomicModel\ntemperature: temperature in Kelvin\nelectron_density: electron density in m^-3\natom_density: total number density (in all levels) of target species\n\nReturns\n\npopulations: MVector{nlevels} with relative level populations in m^-3\n\n\n\n\n\n","category":"method"},{"location":"#Muspel.伪_cont-Union{Tuple{T}, Tuple{ExtinctionItpLTE{T, ITP_2D} where ITP_2D<:(Interpolations.AbstractInterpolation{T, 2}), T, T, T}} where T<:AbstractFloat","page":"Home","title":"Muspel.伪_cont","text":"伪_cont(\n    itp::ExtinctionItpLTE{T},\n    temperature::T,\n    electron_density::T,\n    hydrogen_density::T,\n)\n\nCalculates continuum extinction in m^-1 using interpolant structure.\n\nArguments\n\nitp: Interpolant structure for a given wavelength, hydrogen LTE case\ntemperature: Temperature in K.\nelectron_density: Electron number density in m^-3.\nhydrogen_density: Number density of hydrogen atoms (all stages), unit m^-3.\n\nExamples\n\njulia> npts = 100;\njulia> log_temp = LinRange(3.3, 5, npts);\njulia> log_ne = LinRange(15, 23, npts);\njulia> H_3 = read_atom(\"H_3.yaml\");\njulia> itp_lte = create__itp_LTE(500., log_temp, log_ne, H_3,\n                                  background_atoms, atom_interpolants);\njulia> 伪_cont(itp_lte, 6000., 1e20, 1e20)\n3.59972810095902e-8\n\n\n\n\n\n","category":"method"},{"location":"#Muspel.伪_cont-Union{Tuple{T}, Tuple{ExtinctionItpNLTE{T, ITP_2D, ITP_1D} where {ITP_2D<:(Interpolations.AbstractInterpolation{T, 2}), ITP_1D<:(Interpolations.AbstractInterpolation{T, 1})}, T, T, T, T}} where T<:AbstractFloat","page":"Home","title":"Muspel.伪_cont","text":"伪_cont(\n    itp::ExtinctionItpNLTE{T},\n    temperature::T,\n    electron_density::T,\n    h_neutral_density::T,\n    proton_density::T,\n)\n\nCalculates continuum extinction in m^-1 using interpolant structure.\n\nArguments\n\nitp: Interpolant structure for a given wavelength, hydrogen NLTE case\ntemperature: Temperature in K.\nelectron_density: Electron number density in m^-3.\nh_neutral_density: Number density of neutral hydrogen in m^-3.\nproton_density: Proton number density in m^-3.\n\nExamples\n\njulia> npts = 100;\njulia> log_temp = LinRange(3.3, 5, npts);\njulia> log_ne = LinRange(15, 23, npts);\njulia> itp_nlte = create__itp_LTE(500., log_temp, log_ne,\n                                  background_atoms, atom_interpolants);\njulia> 伪_cont(itp_nlte, 6000., 1e20, 1e20, 4.2462e15)\n3.5998540603635895e-8\n\n\n\n\n\n","category":"method"},{"location":"#Muspel.伪_cont_no_itp-Union{Tuple{T}, NTuple{5, T}} where T<:AbstractFloat","page":"Home","title":"Muspel.伪_cont_no_itp","text":"function 伪_cont_no_itp(\n    位::T,\n    temperature::T,\n    electron_density::T,\n    h_ground_density::T,\n    h_neutral_density::T,\n    proton_density::T\n) where T <: AbstractFloat\n\nCalculates continuum extinction without using an interpolation table. Does not include bound-free processes from background atoms.\n\nArguments\n\n位: Wavelength in nm.\ntemperature: Temperature in K.\nelectron_density: Electron number density in m^-3.\nh_ground_density: Number density of hydrogen in the ground state, unit m^-3.\nh_neutral_density: Number density of neutral hydrogen, unit m^-3.\nproton_density: Proton number density in m^-3.\n\nReturns\n\n伪: Continuous extinction (Float) in m^-1.\n\n\n\n\n\n","category":"method"},{"location":"#Muspel.H_atoms_bf-Union{Tuple{T}, Tuple{Vector{Vector{Interpolations.FilledExtrapolation}}, AbstractVector{AtomicModel}, T, T, T}} where T<:AbstractFloat","page":"Home","title":"Muspel.H_atoms_bf","text":"H_atoms_bf(\n    _atom_tables::Vector{Vector{Interpolations.FilledExtrapolation}},\n    atoms::AbstractVector{AtomicModel},\n    位::T,\n    temperature::T,\n    electron_density::T\n) where T <: AbstractFloat\n\nCompute the bound-free cross-sections per hydrogen atom from bf transitions in model atoms.\n\nArguments\n\natom_interpolants: Interpolation functions from getatomsbf_interpolant().\natoms: A vector of AtomicModels with continua.\n位: Wavelength in nm.\ntemperature: Temperature in K.\nelectron_density: Number density in m^-3.\n\nReturns\n\n_位: Total cross section per hydrogen atom. Corrected for stimulated emission.\n\n\n\n\n\n","category":"method"},{"location":"#Muspel.H_continuum-Union{Tuple{T}, NTuple{4, T}} where T<:AbstractFloat","page":"Home","title":"Muspel.H_continuum","text":"H_continuum(位::T, temperature::T, electron_density::T, ion_frac::T)\n\nCompute continuum cross sections in m^2 per hydrogen atom.\n\nArguments\n\n位: wavelength in nm.\ntemperature: temperature in K.\nelectron_density: number density in m^-3.\nion_frac : ionisation fraction.\n\n\n\n\n\n","category":"method"}]
}
